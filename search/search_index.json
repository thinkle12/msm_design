{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to My Documentation For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-my-documentation","text":"For full documentation visit mkdocs.org .","title":"Welcome to My Documentation"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Quam insurgere tuentur Vidi procumbere cursu utque Lorem markdownum iubis Ut orbes cur turba gurgite gaudia, iamque. Nullam frondes esse victum pelle qualia aut . Inde sub. Fallunt sequiturque flamma color mediis; neve Cephisias digitis crimen tremescere summae: de femina! Hanc hostem quos mergis maxima iam adieci mirantia si Thetis ; sed in pastor primum dubitati petunt sed potens ? var ctrSequence = pramMaximize; row = friendly_io(ppm.sli_wins_remote(hashtag, drm + 2)); stationCompressionApplication = integrated_leak_tiff(ip_gigahertz, ftpGigaflops) * rwMirrored.payload.exbibyteImageUs( personal_app_system, saas) + web_jsp_sink; padWrap = fileCameraVga + sourcePppoe; if (windows + localhostPageVisual <= activexStationPetabyte(rdramOle, horizontal_kerning_mips) + dbmsShiftLun(click, telnet_ssd)) { driveLag(remote_cdfs_plain, 2); lion = lag_jsf_standby + 4; } Stagnum tenetur, pes manant citaeque ausit: agit manu vocem, infra enim dextraque tamen descenderat lanas exspirare? Fretumque nostro. Funesta partemque incepto veniam . Hippomenes officiis pectore mandata me fecit, nec iuvat adultera ubi; tradidit vocem et cetera. Simulavit lata. Animam ille, deprendit fugientis bracchiaque invida miserata undae aut Cereris aere, tuti possent tenentibus. Parem nomen coloni ades adsueta Sideraque nympha porrigit tulit. Ut demittite, dis molis et Elateius parte. Dona sermo, sub coloni cornu corpora manant infecit cuncta mihi est latrantibus pater aut! Me signum, festum: turis at , sequitur armenti et denum reducere Lapitheia et petii, vivit, viscera ! if (mirrored_trim_debug <= modem_xslt(-3, tag_cybercrime)) { thick_quicktime_cpc = matrix_isdn.printerFriend(fios_dvd_ipod, ntfsHubWavelength); host = dos_error_schema + microcomputer; } else { textFacebook += trim / hexadecimalController / recycleGolden + romMyspace; thick.malwareEmoticonStandalone = flowchart_class.bezel(gisClick( internic)); buffer_rte_double.access(wordartSmishingThreading(piracy_telnet, fifo_d_dithering)); } storage_room_data.cd += clickAccessUser.hertz_pptp_cyberbullying( unix_koffice_megahertz(digital)); osd = eccGopherRestore; Dum faciem iactata, et foret ignes exspectato virorum; locus credi, sic periura refert. Viribus gerunt pulsatus adspicias pedem ardetque moderantur frigus desinat, altera origo pressa, anguem Piscibus! Ferunt pia vertice Idas coiere pependit quadripedes inde iam reportat terra; non! Quod vidisset reddita non ut Dulichius caelo, quam, ore variis cervix. Metuque mea omnia pariter. Dies vela, mutataeque miseram satam metuit aestu nullo apta munus. Manus omnibus, fluxit profugum fuerant servaturis te morte; res et. Presso famae, poenaeque, quam, congelat multaque ut. Poteram pectora armis tenderet das tutior: traxere duo quem tollens ferendo; Argolicosque velatus .","title":"About"},{"location":"about/#quam-insurgere-tuentur","text":"","title":"Quam insurgere tuentur"},{"location":"about/#vidi-procumbere-cursu-utque","text":"Lorem markdownum iubis Ut orbes cur turba gurgite gaudia, iamque. Nullam frondes esse victum pelle qualia aut . Inde sub. Fallunt sequiturque flamma color mediis; neve Cephisias digitis crimen tremescere summae: de femina! Hanc hostem quos mergis maxima iam adieci mirantia si Thetis ; sed in pastor primum dubitati petunt sed potens ? var ctrSequence = pramMaximize; row = friendly_io(ppm.sli_wins_remote(hashtag, drm + 2)); stationCompressionApplication = integrated_leak_tiff(ip_gigahertz, ftpGigaflops) * rwMirrored.payload.exbibyteImageUs( personal_app_system, saas) + web_jsp_sink; padWrap = fileCameraVga + sourcePppoe; if (windows + localhostPageVisual <= activexStationPetabyte(rdramOle, horizontal_kerning_mips) + dbmsShiftLun(click, telnet_ssd)) { driveLag(remote_cdfs_plain, 2); lion = lag_jsf_standby + 4; } Stagnum tenetur, pes manant citaeque ausit: agit manu vocem, infra enim dextraque tamen descenderat lanas exspirare? Fretumque nostro. Funesta partemque incepto veniam . Hippomenes officiis pectore mandata me fecit, nec iuvat adultera ubi; tradidit vocem et cetera. Simulavit lata. Animam ille, deprendit fugientis bracchiaque invida miserata undae aut Cereris aere, tuti possent tenentibus.","title":"Vidi procumbere cursu utque"},{"location":"about/#parem-nomen-coloni-ades-adsueta","text":"Sideraque nympha porrigit tulit. Ut demittite, dis molis et Elateius parte. Dona sermo, sub coloni cornu corpora manant infecit cuncta mihi est latrantibus pater aut! Me signum, festum: turis at , sequitur armenti et denum reducere Lapitheia et petii, vivit, viscera ! if (mirrored_trim_debug <= modem_xslt(-3, tag_cybercrime)) { thick_quicktime_cpc = matrix_isdn.printerFriend(fios_dvd_ipod, ntfsHubWavelength); host = dos_error_schema + microcomputer; } else { textFacebook += trim / hexadecimalController / recycleGolden + romMyspace; thick.malwareEmoticonStandalone = flowchart_class.bezel(gisClick( internic)); buffer_rte_double.access(wordartSmishingThreading(piracy_telnet, fifo_d_dithering)); } storage_room_data.cd += clickAccessUser.hertz_pptp_cyberbullying( unix_koffice_megahertz(digital)); osd = eccGopherRestore; Dum faciem iactata, et foret ignes exspectato virorum; locus credi, sic periura refert. Viribus gerunt pulsatus adspicias pedem ardetque moderantur frigus desinat, altera origo pressa, anguem Piscibus! Ferunt pia vertice Idas coiere pependit quadripedes inde iam reportat terra; non! Quod vidisset reddita non ut Dulichius caelo, quam, ore variis cervix. Metuque mea omnia pariter. Dies vela, mutataeque miseram satam metuit aestu nullo apta munus. Manus omnibus, fluxit profugum fuerant servaturis te morte; res et. Presso famae, poenaeque, quam, congelat multaque ut. Poteram pectora armis tenderet das tutior: traxere duo quem tollens ferendo; Argolicosque velatus .","title":"Parem nomen coloni ades adsueta"},{"location":"msm_model_reference/","text":"msm model module Created on Tue Oct 10 22:38:13 2017 @author: Trent msm_model SGD_Online Source code in msm_design/msm_model.py class SGD_Online : def __init__ ( self , wt_seq , pdbfile , sequence_alignment_file = False , reduce_alignment = 2 , output_energy_file = False , custom_tag = False , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = .01 , ridge = False , ridge_coef = .01 , output_cc = True , output_mad = True , rosetta_score_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_database_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ): 'Takes in a pdb file, sequence alignment file, wild type sequence, and energy scoring script' 'We provide two scoring scripts score_sequence_amber.py and score_sequence_rosetta.py' 'The rosetta script requires rosetta protein structure software' 'The amber script requires openmm molecular modeling software as well as rosetta for energy minimization' 'this class must run in command line to make use of energy scoring scripts which output energies to command line' self . pdbfile = pdbfile self . pair_select_list = pair_select_list self . gamma_multiplier = gamma_multiplier self . wt_seq = wt_seq self . regular_linear_regression = regular_linear_regression self . lasso = lasso self . ridge = ridge self . lambda_lasso_coef = lambda_lasso_coef self . ridge_coef = ridge_coef self . output_energy_file = output_energy_file self . output_cc = output_cc self . output_mad = output_mad self . custom_tag = custom_tag self . overall_solution_space = None self . CC = None self . MAD = None self . model_parameters = None self . reduce_alignment = reduce_alignment self . pair_dist = pair_dist self . sequence_alignment_file = sequence_alignment_file self . rosetta_score_path = rosetta_score_path self . rosetta_database_path = rosetta_database_path def online_model ( self , energy_scoring_function = 'rosetta' , num_mutations = 4 , max_computation_time = 252000 , max_training_sets = 50000 , mad_cutoff = 1 , w_start_file = False ): #Scoring function is either 'rosetta' or 'amber' if not self . regular_linear_regression and not self . lasso and not self . ridge : raise ValueError ( 'No model type selected, one of regular_linear_regression, lasso, or ridge must be true' ) if self . regular_linear_regression and self . lasso : raise ValueError ( 'Cannot use both regular and lasso regression, select one or the other' ) if self . regular_linear_regression and self . ridge : raise ValueError ( 'Cannot use both regular and ridge regression, select one or the other' ) if self . ridge and self . lasso : raise ValueError ( 'Cannot use both ridge and lasso regression, select one or the other' ) if self . regular_linear_regression and self . lasso and self . ridge : raise ValueError ( 'Cannot use regular, ridge, and lasso regression at the same time, select one or the other' ) starttime = time . time () max_time = max_computation_time if w_start_file : hh = open ( w_start_file , 'r+' ) newtext = hh . read () newtext = newtext . split ( ' \\n ' ) del newtext [ - 1 ] w = [] for numbers in newtext : w . append ( float ( numbers )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] L = len ( wildtype ) overall_solution_space = import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) trainingsets = max_training_sets madcutoff = mad_cutoff #Here Creating the tag that follows to output files... #This is skipped if a custom_tag variable is defined if not self . custom_tag : if '/' in self . pdbfile : pdbtag = self . pdbfile . split ( '/' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if ' \\\\ ' in self . pdbfile : pdbtag = self . pdbfile . split ( ' \\\\ ' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if self . custom_tag : pdbtag = self . custom_tag print ( 'Filename Tag will be = ' + str ( pdbtag )) if self . output_energy_file : seqEfilename = 'ubiquitin_energies_' + str ( pdbtag ) + '.txt' # the length of the protein reference_seq = wtlist print ( reference_seq ) if self . pair_select_list : position_pairs = pair_select ( self . pdbfile , self . pair_dist , self . wt_seq ) else : position_pairs = [] #Definitions # Sample a random sequence, evaluate its energy according to our energy fucntion, and store the sequence and energy data E_list = [] CC = [] MAD = [] Philist = [] print ( 'Stochastic Gradient Descent' ) print ( '# of pair interactions = %s , %s maximum training sequences, gamma = %s /((i+1)**0.5)' % ( len ( position_pairs ), trainingsets , self . gamma_multiplier )) if self . output_energy_file : open ( seqEfilename , 'w' ) if self . output_cc : open ( 'CC' + str ( pdbtag ) + '.txt' , 'w' ) if self . output_mad : open ( 'MAD' + str ( pdbtag ) + '.txt' , 'w' ) for n in range ( trainingsets ): if time . time () - starttime < max_time : wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] randAAlist = [] for i in range ( num_mutations ): randAAlist . append ( random . randint ( 0 , L - 1 )) for mutantpositions in randAAlist : wtlist [ mutantpositions ] = choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( wtlist ) #cmd = 'python '+str(self.energy_scoring_script)+' %s' % random_seq #1. generate a terminal command as a string #output = Popen(cmd,shell=True,stdout=PIPE).communicate() #2. send the command to the terminal shell #seq_E = float(output[0]) #3. read the result and convert to a float 'Add a new energy scoring function here if wanted' 'Input should be random_seq and an associated pdbfile' 'Should create a definition similar to the two energy function definitions provided' 'if there is a need or want for a different energy function' if energy_scoring_function == 'amber' : seq_E = score_sequence_amber ( random_seq , pdbfile = self . pdbfile , rosetta_path = self . rosetta_score_path , rosetta_db = self . rosetta_database_path ) if energy_scoring_function == 'rosetta' : seq_E = score_sequence_rosetta ( random_seq , pdbfile = self . pdbfile , rosetta_path = self . rosetta_score_path , rosetta_db = self . rosetta_database_path ) #This bypasses Amber not returning scores for certain sequences if seq_E == 'Nan' : print ( 'Sequence did not generate a score' ) pass if seq_E != 'Nan' : #print(seq_E) seq_E = float ( seq_E ) #3. read the result and convert to a float print ( random_seq , seq_E ) if self . output_energy_file : open ( seqEfilename , 'a' ) . write ( random_seq + ',' + str ( seq_E ) + ' \\n ' ) E_list . append ( seq_E ) #Convert Seq to Phi Here seq_Phi = [ 1 ] for i in range ( L ): Phi_i = sigma2Phi ( random_seq [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) if self . pair_select_list : for pair in position_pairs : firstpos = pair [ 0 ] secondpos = pair [ 1 ] pairs_j = pairs ( random_seq [ firstpos ], random_seq [ secondpos ], firstpos , secondpos , overall_solution_space , reference_seq ) seq_Phi . extend ( pairs_j ) else : pass if len ( E_list ) - 1 < 100 : Philist . append ( seq_Phi ) if n == 0 : d = len ( seq_Phi ) if not w_start_file : w = numpy . zeros ( shape = ( d , 1 )) #Starting vector for regular regression not L1 if self . lasso : for f in range ( 1 , len ( Phi_i * L )): w [ f ][ 0 ] = .01 print ( 'Number of Variables in Model = ' + str ( d )) if len ( E_list ) - 1 >= 100 : Philist . append ( seq_Phi ) trainPhi = Philist [ 0 ] del Philist [ 0 ] E_testinglist = [ E_list [ - xx ] for xx in range ( 1 , 101 )] E_testinglist . reverse () trainE = E_list [ len ( E_list ) - 1 - 100 ] weight = 1 gamma = self . gamma_multiplier / (( n + 1 ) ** 0.5 ) # have to do plus one cause first round i = 0 x = numpy . array ([ trainPhi ]) . T # column vector if self . regular_linear_regression : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) #Ridge if self . ridge : w = w - gamma * ( x * weight * ( numpy . dot ( x . T , w ) * weight - trainE ) + self . ridge_coef * w ) #Lasso if self . lasso : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) for j in range ( d ): w [ j ][ 0 ] = STF ( w [ j ][ 0 ], gamma * self . lambda_lasso_coef ) E_estimate = numpy . empty ([ len ( Philist ), 1 ]) for s in range ( len ( Philist )): E_estimate [ s ] = numpy . dot ( Philist [ s ], w [:, 0 ]) E_estimate = E_estimate [:, 0 ] cc = numpy . corrcoef ( E_testinglist , E_estimate )[ 0 , 1 ] mad = numpy . mean ( abs ( E_estimate - E_testinglist )) print ( 'cc = ' + str ( cc )) print ( 'mad = ' + str ( mad )) CC . append ( cc ) # calculate the correlation coeffcient, append into list MAD . append ( mad ) # calculate the mean absolute deviation, append into list if self . output_cc : open ( 'CC' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( cc ) + ' \\n ' ) if self . output_mad : open ( 'MAD' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( mad ) + ' \\n ' ) madlist100 = [] if len ( MAD ) >= 100 : for g in range ( 1 , 101 ): madlist100 . append ( MAD [ - g ]) if all ( mm < float ( madcutoff ) for mm in madlist100 ): break open ( 'w' + str ( pdbtag ) + '.txt' , 'w' ) #open('wState0.txt','w') for vv in range ( len ( w )): open ( 'w' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( w [ vv ][ 0 ]) + ' \\n ' ) self . CC = CC self . MAD = MAD self . model_parameters = w print ( 'energy function fit:' ) print ( ' \\t CC = %0.2f ' % CC [( len ( MAD )) - 1 ]) print ( ' \\t MAD = %0.2f ' % MAD [( len ( MAD )) - 1 ]) #plt.scatter(E_testinglist,E_estimate) #plt.show() #Test to see how many features are zero... zerolist = [] for z in range ( len ( w )): if w [ z ][ 0 ] == 0 : zerolist . append ( z ) print ( 'Number of Features Equal to Zero in the Model = %s ' % len ( zerolist )) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return w __init__ ( self , wt_seq , pdbfile , sequence_alignment_file = False , reduce_alignment = 2 , output_energy_file = False , custom_tag = False , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = 0.01 , ridge = False , ridge_coef = 0.01 , output_cc = True , output_mad = True , rosetta_score_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_database_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ) special Takes in a pdb file, sequence alignment file, wild type sequence, and energy scoring script Source code in msm_design/msm_model.py def __init__ ( self , wt_seq , pdbfile , sequence_alignment_file = False , reduce_alignment = 2 , output_energy_file = False , custom_tag = False , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = .01 , ridge = False , ridge_coef = .01 , output_cc = True , output_mad = True , rosetta_score_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_database_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ): 'Takes in a pdb file, sequence alignment file, wild type sequence, and energy scoring script' 'We provide two scoring scripts score_sequence_amber.py and score_sequence_rosetta.py' 'The rosetta script requires rosetta protein structure software' 'The amber script requires openmm molecular modeling software as well as rosetta for energy minimization' 'this class must run in command line to make use of energy scoring scripts which output energies to command line' self . pdbfile = pdbfile self . pair_select_list = pair_select_list self . gamma_multiplier = gamma_multiplier self . wt_seq = wt_seq self . regular_linear_regression = regular_linear_regression self . lasso = lasso self . ridge = ridge self . lambda_lasso_coef = lambda_lasso_coef self . ridge_coef = ridge_coef self . output_energy_file = output_energy_file self . output_cc = output_cc self . output_mad = output_mad self . custom_tag = custom_tag self . overall_solution_space = None self . CC = None self . MAD = None self . model_parameters = None self . reduce_alignment = reduce_alignment self . pair_dist = pair_dist self . sequence_alignment_file = sequence_alignment_file self . rosetta_score_path = rosetta_score_path self . rosetta_database_path = rosetta_database_path SGD_Static Test header Attributes: Name Type Description scored bool test score arg Returns: list \u2013 test list return Examples: >>> data = SGD_Static () >>> output = data . do_something () Source code in msm_design/msm_model.py class SGD_Static : \"\"\" Test header Attributes: scored (bool): test score arg Returns: list: test list return Example: >>> data = SGD_Static() >>> output = data.do_something() \"\"\" def __init__ ( self , pdbfile , sequence_energy_file , wt_seq , sequence_alignment_file = False , reduce_alignment = 1 , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = .01 , ridge = False , ridge_coef = .01 , custom_tag = False ): self . pdbfile = pdbfile self . sequence_energy_file = sequence_energy_file self . sequence_alignment_file = sequence_alignment_file self . pair_select_list = pair_select_list self . gamma_multiplier = gamma_multiplier self . wt_seq = wt_seq self . regular_linear_regression = regular_linear_regression self . lasso = lasso self . ridge = ridge self . lambda_lasso_coef = lambda_lasso_coef self . ridge_coef = ridge_coef self . custom_tag = custom_tag self . overall_solution_space = None self . energies = None self . sequences = None self . CC = None self . MAD = None self . model_parameters = None self . pair_dist = pair_dist self . reduce_alignment = reduce_alignment def static_model ( self , mad_thresh = .01 , model_output_text_file = False , display_plots = True ): if not self . regular_linear_regression and not self . lasso and not self . ridge : raise ValueError ( 'No model type selected, one of regular_linear_regression, lasso, or ridge must be true' ) if self . regular_linear_regression and self . lasso : raise ValueError ( 'Cannot use both regular and lasso regression, select one or the other' ) if self . regular_linear_regression and self . ridge : raise ValueError ( 'Cannot use both regular and ridge regression, select one or the other' ) if self . ridge and self . lasso : raise ValueError ( 'Cannot use both ridge and lasso regression, select one or the other' ) if self . regular_linear_regression and self . lasso and self . ridge : raise ValueError ( 'Cannot use regular, ridge, and lasso regression at the same time, select one or the other' ) starttime = time . time () #max_time = 252000 max_time = 5000000 start_time = time . time () if not self . custom_tag : if '/' in self . pdbfile : pdbtag = self . pdbfile . split ( '/' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if ' \\\\ ' in self . pdbfile : pdbtag = self . pdbfile . split ( ' \\\\ ' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if self . custom_tag : pdbtag = self . custom_tag print ( 'Filename Tag will be = ' + str ( pdbtag )) L = len ( self . wt_seq ) # the length of the protein overall_solution_space = import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) #wildtype = 'MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG' wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) h = open ( self . sequence_energy_file , 'r+' ) text = h . read () text = text . split ( ' \\n ' ) del text [ - 1 ] sequences = [ t . split ( ',' )[ 0 ] for t in text ] Energies = [ float ( t . split ( ',' )[ 1 ]) for t in text ] self . sequences = sequences self . energies = Energies if self . pair_select_list : position_pairs = pair_select ( self . pdbfile , self . pair_dist , self . wt_seq ) else : position_pairs = [] # Sample a random sequence, evaluate its energy according to our energy fucntion, and store the sequence and energy data trainingsets = len ( Energies ) print ( 'Number of training sets = ' + str ( len ( Energies ))) E_list = [] random_Seq_list = [] CC = [] MAD = [] #w = [] Philist = [] trainE = [] trainPhi = [] print ( 'Stochastic Gradient Descent Multivariate Linear Regression' ) print ( '# of pair interactions = %s , gamma = %s /((i+1)**0.5)' % ( len ( position_pairs ), self . gamma_multiplier )) print ( ' \\n ' ) for n in range ( trainingsets ): if time . time () - start_time < max_time : random_Seq_list . append ( sequences [ n ]) E_list . append ( Energies [ n ]) #Convert Seq to Phi Here seq_Phi = [ 1 ] for i in range ( L ): Phi_i = sigma2Phi ( random_Seq_list [ n ][ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) if self . pair_select_list : for pair in position_pairs : firstpos = pair [ 0 ] secondpos = pair [ 1 ] pairs_j = pairs ( random_Seq_list [ n ][ firstpos ], random_Seq_list [ n ][ secondpos ], firstpos , secondpos , overall_solution_space , reference_seq ) seq_Phi . extend ( pairs_j ) else : pass if n < 100 : Philist . append ( seq_Phi ) if n == 0 : d = len ( seq_Phi ) w = numpy . zeros ( shape = ( d , 1 )) #Starting vector for regular regression not L1 if self . lasso : for f in range ( 1 , len ( Phi_i * L )): w [ f ][ 0 ] = .01 print ( 'Number of Variables in Model = ' + str ( d )) if n >= 100 : Philist . append ( seq_Phi ) trainPhi = Philist [ 0 ] del Philist [ 0 ] E_testinglist = [ E_list [ - xx ] for xx in range ( 1 , 101 )] E_testinglist . reverse () trainE = E_list [ n - 100 ] weight = 1 gamma = self . gamma_multiplier / (( n - 100 + 1 ) ** 0.5 ) x = numpy . array ([ trainPhi ]) . T # column vector if self . regular_linear_regression : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) #Ridge if self . ridge : w = w - gamma * ( x * weight * ( numpy . dot ( x . T , w ) * weight - trainE ) + self . ridge_coef * w ) #Lasso if self . lasso : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) for j in range ( d ): w [ j ][ 0 ] = STF ( w [ j ][ 0 ], gamma * self . lambda_lasso_coef ) # analyze the fit of the current model w #Regular Matrix Multiplication E_estimate = numpy . empty ([ len ( Philist ), 1 ]) for s in range ( len ( Philist )): E_estimate [ s ] = numpy . dot ( Philist [ s ], w [:, 0 ]) E_estimate = E_estimate [:, 0 ] cc = numpy . corrcoef ( E_testinglist , E_estimate )[ 0 , 1 ] mad = numpy . mean ( abs ( E_estimate - E_testinglist )) CC . append ( cc ) # calculate the correlation coeffcient, append into list MAD . append ( float ( mad )) # calculate the mean absolute deviation, append into list stdout . write ( ' \\r Training set = %s ' % str ( n + 1 )) #This prints the current training set index on same line as an update stdout . flush () madlist100 = [] if len ( MAD ) >= 100 : for g in range ( 1 , 101 ): madlist100 . append ( MAD [ - g ]) if all ( mm < float ( mad_thresh ) for mm in madlist100 ): break if model_output_text_file : open ( 'w' + str ( pdbtag ) + '.txt' , 'w' ) for vv in range ( len ( w )): open ( 'w' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( w [ vv ][ 0 ]) + ' \\n ' ) self . CC = CC self . MAD = MAD self . model_parameters = w if display_plots : import matplotlib.pyplot as plt plt . plot ( range ( len ( MAD )), MAD ) plt . show () plt . plot ( range ( len ( CC )), CC ) plt . show () plt . scatter ( E_testinglist , E_estimate ) plt . show () print ( 'energy function fit:' ) print ( ' \\t CC = %0.2f ' % CC [( len ( MAD )) - 1 ]) print ( ' \\t MAD = %0.2f ' % MAD [( len ( MAD )) - 1 ]) #Test to see how many features are zero... zerolist = [] for z in range ( len ( w )): if w [ z ][ 0 ] == 0 : zerolist . append ( z ) print ( 'Number of Features Equal to Zero in the Model = %s ' % len ( zerolist )) sumlist = [] for i in range ( 1000 ): sumlist . append ( MAD [ - i ]) print ( 'Avg MAD of last 1000 terms = ' + str ( sum ( sumlist ) / 1000 )) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return w pair_select ( pdbfile , dist , wt_seq ) Here we select the maximum distance for a pair of AAs to be considered important Source code in msm_design/msm_model.py def pair_select ( pdbfile , dist , wt_seq ): \"Here we select the maximum distance for a pair of AAs to be considered important\" angstrom_distance = dist ######################################################################### #this should really use the 'state' pdb files.... L = len ( wt_seq ) #AAs = ['A', 'C', 'D', 'E', 'F', 'G', 'H','I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W','Y'] #all 20 amino acids pdbdata = open ( pdbfile ) . read () pdblines = pdbdata . split ( ' \\n ' ) coordinates = [] for line in pdblines : if line [: 4 ] == 'ATOM' : coordinates . append ( line ) #\"Why is there a lot of extra sequences in the pdb file\" #for i in range(4123): # coordinates.pop() \"Here we make lists of all atoms x,y,z coordinates and pair them by which AA they are in into lists, each list corresponds to the atoms in each AA\" xcoors = {} for q in range ( 1 , L + 1 ): xcoors [ 'AAxcoor' + str ( q )] = [] for j in range ( L + 1 ): for line in coordinates : if int ( line [ 22 : 26 ]) == j : x = line [ 30 : 38 ] xnum = float ( x ) xcoors [ 'AAxcoor' + str ( j )] . append ( xnum ) ycoors = {} for q in range ( 1 , L + 1 ): ycoors [ 'AAycoor' + str ( q )] = [] for k in range ( L + 1 ): for line in coordinates : if int ( line [ 22 : 26 ]) == k : y = line [ 38 : 46 ] ynum = float ( y ) ycoors [ 'AAycoor' + str ( k )] . append ( ynum ) zcoors = {} for q in range ( 1 , L + 1 ): zcoors [ 'AAzcoor' + str ( q )] = [] for s in range ( L + 1 ): for line in coordinates : if int ( line [ 22 : 26 ]) == s : z = line [ 46 : 54 ] znum = float ( z ) zcoors [ 'AAzcoor' + str ( s )] . append ( znum ) \"Pair all xyz together\" listofxyz = {} for q in range ( 1 , L + 1 ): listofxyz [ 'listofxyz' + str ( q )] = [] \"XYZ points of all atoms sorted into lists of corresponding AAs\" for q in range ( 1 , L + 1 ): for j in range ( len ( xcoors [ 'AAxcoor' + str ( q )])): listofxyz [ 'listofxyz' + str ( q )] . append (( xcoors [ 'AAxcoor' + str ( q )][ j ], ycoors [ 'AAycoor' + str ( q )][ j ], zcoors [ 'AAzcoor' + str ( q )][ j ])) \"Here we find the distance between every atom in the protein separated by the atoms that belong to specific AAs\" atomtoatom = {} for i in range ( 1 , L + 1 ): for j in range ( 1 , L + 1 ): if i < j : atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )] = [] for k in range ( len ( listofxyz [ 'listofxyz' + str ( i )])): for f in range ( len ( listofxyz [ 'listofxyz' + str ( j )])): atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )] . append ( numpy . linalg . norm ( numpy . array ( listofxyz [ 'listofxyz' + str ( i )])[ k ] - numpy . array ( listofxyz [ 'listofxyz' + str ( j )])[ f ])) \"Here we take the minimum distance between atoms between all AAs\" minimumdistances = {} for i in range ( 1 , L + 1 ): for j in range ( 1 , L + 1 ): if i < j and atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )] != []: #New shit here... minimumdistances [ 'minimumdistances' + str ( i ) + '-' + str ( j )] = [] minimumdistances [ 'minimumdistances' + str ( i ) + '-' + str ( j )] = min ( atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )]) \"Here we determine which pairs are close enough by setting an angstrom_distance constraint\" closeatoms = [] for i in range ( 1 , L + 1 ): for j in range ( 1 , L + 1 ): if all ([ i < j and minimumdistances [ 'minimumdistances' + str ( i ) + '-' + str ( j )] < float ( angstrom_distance )]): #if all([i<j and minimumdistances['minimumdistances'+str(i)+'-'+str(j)]<float(angstrom_distance) and abs(i-j)!=1]): closeatoms . append (( i , j )) \"Here we subtract of (1,1) from each pair to match the indecies of the regression format\" newcloseatoms = numpy . array ( closeatoms ) - ( 1 , 1 ) newcloseatoms = map ( tuple , newcloseatoms ) print ( len ( newcloseatoms )) return newcloseatoms score_sequence_amber ( newseq = None , pdbfile = None , rosetta_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_db = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ) Provide rosetta path to fixbb.linuxgccrelease Source code in msm_design/msm_model.py def score_sequence_amber ( newseq = None , pdbfile = None , rosetta_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_db = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ): 'Provide rosetta path to fixbb.linuxgccrelease' from random import choice from os import remove import simtk.openmm.app as app import simtk.openmm as op import simtk.unit as unit def rand_tag (): '''creates a unique tag that can be used to identify the current files a script is working with. necessary for running the same program multiple times in the same directory''' alpha = 'abcdefghijklmnopqrstuvwxyz0123456789' tag = '' . join ([ choice ( alpha ) for i in range ( 15 )]) return tag def thread_repack_score_amber ( pdbfile , newseq ): tag = rand_tag () # generate a random tag to associate with this run # generate a resfile to mutate the pdb resfile = \"\"\" #header NATAA # keep this so all sites aren't designed USE_INPUT_SC # this to also consider the WT rotamer, if we're mutating WT to WT start #body \\n \"\"\" for i in range ( len ( newseq )): resfile += ' %i A PIKAA %s \\n ' % ( i + 1 , newseq [ i ]) open ( 'resfile_' + tag + '.res' , 'w' ) . write ( resfile ) # the options for the run options = [ 'nice' , rosetta_path + 'fixbb.linuxgccrelease' , # fixbb is the program used for threading a repacking '-s ' + pdbfile , '-database ' + rosetta_db , # good to explicitly define location of rosetta DB '-resfile resfile_' + tag + '.res' , # a resfile to specify mutations '-out:suffix _' + tag ] # this adds a suffix to the score output file: score_[RNDTAG].sc # run fixbb Popen ( options , stdout = open ( '/dev/null' , 'w' )) . wait () # send stdout to the trash, report stderr # read the output scorefile = open ( 'score_ %s .sc' % tag ) . read () . split ( ' \\n ' ) names = scorefile [ 1 ] . split ( ':' )[ 1 ] . split () values = scorefile [ 2 ] . split ( ':' )[ 1 ] . split () score = dict (( names [ i ], float ( values [ i ])) for i in range ( len ( names ) - 1 )) # use i-1 because the last entry is the filename pdbname = ( pdbfile [: - 4 ] + '_' + tag + '_0001.pdb' ) . split ( '/' )[ - 1 ] # now load into openMM and score with amber pdb = app . PDBFile ( pdbname ) forcefield = app . ForceField ( 'amber03.xml' , 'amber03_obc.xml' ) system = forcefield . createSystem ( pdb . topology , nonbondedMethod = app . NoCutoff , constraints = None ) integrator = op . LangevinIntegrator ( 300 * unit . kelvin , 1 / unit . picosecond , 1e-9 * unit . picoseconds ) simulation = app . Simulation ( pdb . topology , system , integrator ) simulation . context . setPositions ( pdb . positions ) #Must do try/except here because Amber occasionally throws an Exception error and does not return a score try : simulation . minimizeEnergy () state = simulation . context . getState ( getPositions = True , getEnergy = True ) score = state . getPotentialEnergy () / unit . kilojoule_per_mole except Exception : score = 'Nan' pass #delete the evidence remove ( 'score_ %s .sc' % tag ) remove ( 'resfile_' + tag + '.res' ) remove ( pdbname ) return score score = thread_repack_score_amber ( pdbfile , newseq ) return score sigma2Phi ( sigma , i , overall_solution_space , reference_seq ) This takes in an amino acid and a position and returns the 1x19 binary indicator vector Phi Source code in msm_design/msm_model.py def sigma2Phi ( sigma , i , overall_solution_space , reference_seq ): \"\"\"This takes in an amino acid and a position and returns the 1x19 binary indicator vector Phi\"\"\" AAchanges = [ aa for aa in overall_solution_space [ i ] if aa != reference_seq [ i ]] # these are all 19 possible AA changes (i.e. AAs that are not the reference sequence AA) #AAchanges = [aa for aa in AAs if aa!=reference_seq[i]] Phi = [] for aa in AAchanges : if sigma == aa : Phi . append ( 1 ) else : Phi . append ( 0 ) return Phi msm_optimization Created on Wed Jan 18 23:26:11 2017 @author: Trent Sequence_Optimization Source code in msm_design/msm_optimization.py class Sequence_Optimization : def __init__ ( self , model_file_dir , wt_seq , sequence_alignment_file = False , reduce_alignment = 1 , mad_file_dir = False , cc_file_dir = False , display_plot = True , pair_interaction_dist = False , pdb_dir = False ): self . model_file_dir = model_file_dir self . mad_file_dir = mad_file_dir self . cc_file_dir = cc_file_dir self . wt_seq = wt_seq self . sequence_alignment_file = sequence_alignment_file self . display_plot = display_plot self . best_results = None self . reduce_alignment = reduce_alignment # if pair_interaction_dist and pdb_dir: # # pair_interaction_list=Msm_Design.pair_select(pdbfile,pair_interaction_dist,wt_seq) # self.pair_interaction_list = pair_interaction_list def import_model_files ( self ): newfilelist = os . listdir ( self . model_file_dir ) newnamelist = [] for newnames in newfilelist : newnamelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) wStates = {} for q in range ( len ( newfilelist )): wStates [ 'wState' + str ( newnamelist [ q ])] = [] for j in range ( len ( newfilelist )): hh = open ( self . model_file_dir + str ( newfilelist [ j ]), 'r+' ) newtext = hh . read () newtext = newtext . split ( ' \\n ' ) del newtext [ - 1 ] newfloatedlist = [] for numbers in newtext : newfloatedlist . append ( float ( numbers )) wStates [ 'wState' + str ( newnamelist [ j ])] = numpy . array ( newfloatedlist ) return wStates def test_model_performance ( self ): if self . mad_file_dir : filelist = os . listdir ( self . mad_file_dir ) #print filelist namelist = [] for names in filelist : namelist . append ( re . sub ( \"[^0-9]\" , '' , names )) MADStates = {} for q in range ( len ( filelist )): MADStates [ 'MADState' + str ( namelist [ q ])] = [] sumlist = [] for j in range ( len ( filelist )): h = open ( self . mad_file_dir + str ( filelist [ j ]), 'r+' ) text = h . read () text = text . split ( ' \\n ' ) #text = pickle.load(open('seq_energies_state0_ubiquitin.p')) del text [ - 1 ] floatedlist = [] for items in text : try : floatedlist . append ( float ( items )) except ValueError : pass if floatedlist != []: MADStates [ 'MADState' + str ( namelist [ j ])] = floatedlist thousandlist = [] if len ( floatedlist ) < 1000 : for i in range ( len ( floatedlist )): thousandlist . append ( floatedlist [ i ]) sumlist . append ( sum ( thousandlist ) / len ( thousandlist )) if len ( floatedlist ) >= 1000 : for i in range ( 1 , 1001 ): thousandlist . append ( floatedlist [ - i ]) sumlist . append ([ sum ( thousandlist ) / 1000 ]) sumlist [ - 1 ] . append ( str ( filelist [ j ])) print ( sumlist ) return sumlist else : print ( 'No MAD Directory Set' ) def generate_seq_energy ( self , seq , state_number ): 'Pair models not yet supported' wStates = self . import_model_files () overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , len ( self . wt_seq )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( len ( self . wt_seq )): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(lowESeqtest[n][firstpos],lowESeqtest[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi rnd_list = [] for j in range ( len ( seq )): if seq [ j ] not in overall_solution_space [ j ]: print ( 'Residue ' + str ( seq [ j ]) + ' at position ' + str ( j ) + ' not in amino acid space ' + str ( overall_solution_space [ j ])) rnd_list . append ( j ) break if len ( rnd_list ) <= 0 : binary_seq = binary_conversion ( seq ) energy = numpy . dot ( binary_seq , wStates [ 'wState' + str ( state_number )]) return energy def single_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 8.31447e-3 , mut_thresh = 10 , num_mutation_pathway_passes = 500 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ): 'Pair distances not supported' mutation_threshold = len ( self . wt_seq ) - mut_thresh starttime = time . time () if self . mad_file_dir : print ( self . test_model_performance ()) else : pass wStates = self . import_model_files () modelsfiles = os . listdir ( self . model_file_dir ) modelsfilelist = [] for newnames in modelsfiles : modelsfilelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) L = len ( self . wt_seq ) # this is the amino acids allowed at each postion overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( L ): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(sequence[n][firstpos],sequence[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi def single_probability_estimation ( binary , State_to_optimize , mean ): E_estimate = math . exp ( - ( numpy . dot ( binary , wStates [ 'w' + str ( State_to_optimize )]) - mean ) / ( k * t )) return E_estimate def multi_probability_estimation ( binary , mean ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_estimate_mult = math . exp ( - ( numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) - mean ) / ( k * t )) State_E_list . append ( E_estimate_mult ) return sum ( State_E_list ) def energy_mean_calc ( binary ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_mult = numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) State_E_list . append ( E_mult ) return numpy . mean ( State_E_list ) if write_opt_file_name : opt_filename = write_opt_file_name open ( opt_filename , 'w' ) open ( opt_filename , 'a' ) . write ( 'Probability' + ',' + str ( 'Sequence' ) + ',' + str ( 'chosen_state' ) + ' \\n ' ) #state_opt = ['State12'] #Might need to take out WT mutations from overall_solution_space to avoid mutating to wt best_seq_perstate_permutnum = {} if pdf_output_plot : from matplotlib.backends.backend_pdf import PdfPages pp = PdfPages ( pdf_output_plot ) for state_num in states_to_optimize_for_by_state_number : chosen_state = 'State' + str ( state_num ) print ( chosen_state ) rand_seq_list = [] boltz_list = [] objective_func_sequence_dict = {} for muts in range ( L - mutation_threshold + 1 ): objective_func_sequence_dict [ 'Mutations_' + str ( muts )] = [] #Test Optimization overall = [] for nn in range ( num_mutation_pathway_passes ): trial = [] for n in range ( inner_loop_trials ): if len ( trial ) <= mut_thresh : if n == 0 : aminoacidchain = [ wildtype [ i ] for i in range ( len ( wildtype ))] random_seq = '' . join ( aminoacidchain ) rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( random_seq ) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , random_seq ]) trial . append ( boltz_dist ) if n > 0 : randAAlist = [] for i in range ( 1 ): randAAlist . append ( random . randint ( 0 , L - 1 )) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : aachaintobemutated = list ( aminoacidchain ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : aachaintobemutated = list ( rand_seq_list [ - 1 ]) for mutantpositions in randAAlist : aachaintobemutated [ mutantpositions ] = random . choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( aachaintobemutated ) listseq = list ( random_seq ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : rand_seq_list . append ( listseq ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) if boltz_list [ - 1 ] > boltz_list [ - 2 ]: trial . append ( boltz_dist ) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , '' . join ( listseq )]) pass if boltz_list [ - 1 ] <= boltz_list [ - 2 ]: del rand_seq_list [ - 1 ] del boltz_list [ - 1 ] stdout . write ( ' \\r Mutation Pathway Number = %s ' % str ( nn + 1 )) #This prints the current training set index on same line as an update stdout . flush () overall . append ( trial ) best_seq_perstate_permutnum [ str ( chosen_state )] = [] for muts in range ( L - mutation_threshold + 1 ): try : best_seq_perstate_permutnum [ str ( chosen_state )] . append ( max ( objective_func_sequence_dict [ 'Mutations_' + str ( muts )])) except ValueError : pass print ( ' \\n ' ) if self . display_plot and plot_separate : import matplotlib.pyplot as plt listt = [] for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): listt . append ([ i , best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . scatter ( states , probs ) plt . title ( 'Single State Optimization for State ' + str ( state_num )) if pdf_output_plot : pp . savefig () #plt.show() plt . close () if write_opt_file_name : for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): open ( opt_filename , 'a' ) . write ( str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]) + ',' + str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 1 ]) + ',' + str ( chosen_state ) + ',' + str ( 'num_Mutations = ' ) + str ( i ) + ' \\n ' ) if pdf_output_plot : pp . close () self . best_results = best_seq_perstate_permutnum if self . display_plot and plot_together : import matplotlib.pyplot as plt for stuff in best_seq_perstate_permutnum : listt = [] for i in range ( len ( best_seq_perstate_permutnum [ stuff ])): listt . append ([ i , best_seq_perstate_permutnum [ stuff ][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . title ( 'Log Shifted Probability Plot' + ' \\n ' + 'For Most Probable Sequence Per State Per Mutation Number' ) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Log of Probability' ) plt . scatter ( states , probs ) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return best_seq_perstate_permutnum def two_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 8.31447e-3 , mut_thresh = 10 , num_mutation_pathway_passes = 100 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ): mutation_threshold = len ( self . wt_seq ) - mut_thresh starttime = time . time () if self . mad_file_dir : print ( self . test_model_performance ()) else : pass wStates = self . import_model_files () modelsfiles = os . listdir ( self . model_file_dir ) modelsfilelist = [] for newnames in modelsfiles : modelsfilelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) L = len ( self . wt_seq ) # this is the amino acids allowed at each postion overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , len ( self . wt_seq )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( L ): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(lowESeqtest[n][firstpos],lowESeqtest[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi def single_probability_estimation ( binary , State_to_optimize , mean ): E_estimate = math . exp ( - ( numpy . dot ( binary , wStates [ 'w' + str ( State_to_optimize )]) - mean ) / ( k * t )) return E_estimate def multi_probability_estimation ( binary , mean ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_estimate_mult = math . exp ( - ( numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) - mean ) / ( k * t )) State_E_list . append ( E_estimate_mult ) return sum ( State_E_list ) def energy_mean_calc ( binary ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_mult = numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) State_E_list . append ( E_mult ) return numpy . mean ( State_E_list ) if write_opt_file_name : opt_filename = write_opt_file_name open ( opt_filename , 'w' ) open ( opt_filename , 'a' ) . write ( 'Objective_Function_Value' + ',' + str ( 'Sequence' ) + ',' + str ( 'chosen_state1' ) + ',' + str ( 'chosen_state2' ) + ' \\n ' ) best_seq_perstate_permutnum = {} if pdf_output_plot : from matplotlib.backends.backend_pdf import PdfPages pp = PdfPages ( pdf_output_plot ) #Might need to take out WT mutations from overall_solution_space to avoid mutating to wt #Test Optimization for jj in range ( len ( states_to_optimize_for_by_state_number )): state_num1 = states_to_optimize_for_by_state_number [ jj ][ 0 ] state_num2 = states_to_optimize_for_by_state_number [ jj ][ 1 ] chosen_state1 = 'State' + str ( state_num1 ) chosen_state2 = 'State' + str ( state_num2 ) print ( chosen_state1 ) print ( chosen_state2 ) two_state_opt_list = [] boltz_list1 = [] boltz_list2 = [] rand_seq_list = [] objective_func_sequence_dict = {} for muts in range ( L - mutation_threshold + 1 ): objective_func_sequence_dict [ 'Mutations_' + str ( muts )] = [] overall = [] for nn in range ( num_mutation_pathway_passes ): trial = [] for n in range ( inner_loop_trials ): if len ( trial ) <= mut_thresh : if n == 0 : aminoacidchain = [ wildtype [ i ] for i in range ( len ( wildtype ))] random_seq = '' . join ( aminoacidchain ) rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( random_seq ) mean_energy = energy_mean_calc ( Phi ) single_E1 = single_probability_estimation ( Phi , chosen_state1 , mean_energy ) single_E2 = single_probability_estimation ( Phi , chosen_state2 , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist1 = single_E1 / multi_E boltz_dist2 = single_E2 / multi_E boltz_list1 . append ( boltz_dist1 ) boltz_list2 . append ( boltz_dist2 ) opt_func = ( boltz_dist1 - .5 ) ** 2 + ( boltz_dist2 - .5 ) ** 2 two_state_opt_list . append ( opt_func ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ opt_func , '' . join ( aminoacidchain ), boltz_dist1 , boltz_dist2 ]) trial . append ( opt_func ) if n > 0 : randAAlist = [] for i in range ( 1 ): randAAlist . append ( random . randint ( 0 , L - 1 )) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : aachaintobemutated = list ( aminoacidchain ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : aachaintobemutated = list ( rand_seq_list [ - 1 ]) for mutantpositions in randAAlist : aachaintobemutated [ mutantpositions ] = random . choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( aachaintobemutated ) listseq = list ( random_seq ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) mean_energy = energy_mean_calc ( Phi ) single_E1 = single_probability_estimation ( Phi , chosen_state1 , mean_energy ) single_E2 = single_probability_estimation ( Phi , chosen_state2 , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist1 = single_E1 / multi_E boltz_dist2 = single_E2 / multi_E boltz_list1 . append ( boltz_dist1 ) boltz_list2 . append ( boltz_dist2 ) opt_func = ( boltz_dist1 - .5 ) ** 2 + ( boltz_dist2 - .5 ) ** 2 two_state_opt_list . append ( opt_func ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : rand_seq_list . append ( listseq ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) mean_energy = energy_mean_calc ( Phi ) single_E1 = single_probability_estimation ( Phi , chosen_state1 , mean_energy ) single_E2 = single_probability_estimation ( Phi , chosen_state2 , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist1 = single_E1 / multi_E boltz_dist2 = single_E2 / multi_E boltz_list1 . append ( boltz_dist1 ) boltz_list2 . append ( boltz_dist2 ) opt_func = ( boltz_dist1 - .5 ) ** 2 + ( boltz_dist2 - .5 ) ** 2 two_state_opt_list . append ( opt_func ) Mut_num = 76 - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) if ( boltz_list1 [ - 1 ] > boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] > boltz_list2 [ - 2 ]): #if two_state_opt_list[-1]<=two_state_opt_list[-2]: trial . append ( opt_func ) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ opt_func , '' . join ( listseq ), boltz_dist1 , boltz_dist2 ]) pass if ( boltz_list1 [ - 1 ] <= boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] <= boltz_list2 [ - 2 ]) or ( boltz_list1 [ - 1 ] > boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] <= boltz_list2 [ - 2 ]) or ( boltz_list1 [ - 1 ] <= boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] > boltz_list2 [ - 2 ]): #if two_state_opt_list[-1]>two_state_opt_list[-2]: del rand_seq_list [ - 1 ] del two_state_opt_list [ - 1 ] del boltz_list1 [ - 1 ] del boltz_list2 [ - 1 ] stdout . write ( ' \\r Mutation Pathway Number = %s ' % str ( nn + 1 )) #This prints the current training set index on same line as an update stdout . flush () print ( ' \\n ' ) overall . append ( trial ) best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )] = [] for muts in range ( L - mutation_threshold + 1 ): best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )] . append ( min ( objective_func_sequence_dict [ 'Mutations_' + str ( muts )])) if self . display_plot and plot_separate : import matplotlib.pyplot as plt listt = [] for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )])): listt . append ([ i , best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ x [ 1 ] for x in listt ] plt . scatter ( states , probs ) plt . title ( 'Two State Optimization for State' + str ( state_num1 ) + ' and State' + str ( state_num2 )) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Objective Function Value' ) if pdf_output_plot : pp . savefig () #plt.show() plt . close () if write_opt_file_name : for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )])): open ( opt_filename , 'a' ) . write ( str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 0 ]) + ',' + str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 1 ]) + ',' + str ( chosen_state1 ) + '_probability=' + str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 2 ]) + ',' + str ( chosen_state2 ) + '_probability=' + str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 3 ]) + ',' + str ( 'num_Mutations=' ) + str ( i ) + ' \\n ' ) if pdf_output_plot : pp . close () if self . display_plot and plot_together : import matplotlib.pyplot as plt for stuff in best_seq_perstate_permutnum : listt = [] for i in range ( len ( best_seq_perstate_permutnum [ stuff ])): listt . append ([ i , best_seq_perstate_permutnum [ stuff ][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ x [ 1 ] for x in listt ] plt . scatter ( states , probs ) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Objective Function Value' ) plt . title ( 'Two State Optimization for All Defined Pairs of States' ) self . best_results = best_seq_perstate_permutnum print ( ' \\n ' ) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) generate_seq_energy ( self , seq , state_number ) Pair models not yet supported Source code in msm_design/msm_optimization.py def generate_seq_energy ( self , seq , state_number ): 'Pair models not yet supported' wStates = self . import_model_files () overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , len ( self . wt_seq )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( len ( self . wt_seq )): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(lowESeqtest[n][firstpos],lowESeqtest[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi rnd_list = [] for j in range ( len ( seq )): if seq [ j ] not in overall_solution_space [ j ]: print ( 'Residue ' + str ( seq [ j ]) + ' at position ' + str ( j ) + ' not in amino acid space ' + str ( overall_solution_space [ j ])) rnd_list . append ( j ) break if len ( rnd_list ) <= 0 : binary_seq = binary_conversion ( seq ) energy = numpy . dot ( binary_seq , wStates [ 'wState' + str ( state_number )]) return energy single_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 0.00831447 , mut_thresh = 10 , num_mutation_pathway_passes = 500 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ) Pair distances not supported Source code in msm_design/msm_optimization.py def single_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 8.31447e-3 , mut_thresh = 10 , num_mutation_pathway_passes = 500 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ): 'Pair distances not supported' mutation_threshold = len ( self . wt_seq ) - mut_thresh starttime = time . time () if self . mad_file_dir : print ( self . test_model_performance ()) else : pass wStates = self . import_model_files () modelsfiles = os . listdir ( self . model_file_dir ) modelsfilelist = [] for newnames in modelsfiles : modelsfilelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) L = len ( self . wt_seq ) # this is the amino acids allowed at each postion overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( L ): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(sequence[n][firstpos],sequence[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi def single_probability_estimation ( binary , State_to_optimize , mean ): E_estimate = math . exp ( - ( numpy . dot ( binary , wStates [ 'w' + str ( State_to_optimize )]) - mean ) / ( k * t )) return E_estimate def multi_probability_estimation ( binary , mean ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_estimate_mult = math . exp ( - ( numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) - mean ) / ( k * t )) State_E_list . append ( E_estimate_mult ) return sum ( State_E_list ) def energy_mean_calc ( binary ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_mult = numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) State_E_list . append ( E_mult ) return numpy . mean ( State_E_list ) if write_opt_file_name : opt_filename = write_opt_file_name open ( opt_filename , 'w' ) open ( opt_filename , 'a' ) . write ( 'Probability' + ',' + str ( 'Sequence' ) + ',' + str ( 'chosen_state' ) + ' \\n ' ) #state_opt = ['State12'] #Might need to take out WT mutations from overall_solution_space to avoid mutating to wt best_seq_perstate_permutnum = {} if pdf_output_plot : from matplotlib.backends.backend_pdf import PdfPages pp = PdfPages ( pdf_output_plot ) for state_num in states_to_optimize_for_by_state_number : chosen_state = 'State' + str ( state_num ) print ( chosen_state ) rand_seq_list = [] boltz_list = [] objective_func_sequence_dict = {} for muts in range ( L - mutation_threshold + 1 ): objective_func_sequence_dict [ 'Mutations_' + str ( muts )] = [] #Test Optimization overall = [] for nn in range ( num_mutation_pathway_passes ): trial = [] for n in range ( inner_loop_trials ): if len ( trial ) <= mut_thresh : if n == 0 : aminoacidchain = [ wildtype [ i ] for i in range ( len ( wildtype ))] random_seq = '' . join ( aminoacidchain ) rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( random_seq ) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , random_seq ]) trial . append ( boltz_dist ) if n > 0 : randAAlist = [] for i in range ( 1 ): randAAlist . append ( random . randint ( 0 , L - 1 )) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : aachaintobemutated = list ( aminoacidchain ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : aachaintobemutated = list ( rand_seq_list [ - 1 ]) for mutantpositions in randAAlist : aachaintobemutated [ mutantpositions ] = random . choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( aachaintobemutated ) listseq = list ( random_seq ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : rand_seq_list . append ( listseq ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) if boltz_list [ - 1 ] > boltz_list [ - 2 ]: trial . append ( boltz_dist ) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , '' . join ( listseq )]) pass if boltz_list [ - 1 ] <= boltz_list [ - 2 ]: del rand_seq_list [ - 1 ] del boltz_list [ - 1 ] stdout . write ( ' \\r Mutation Pathway Number = %s ' % str ( nn + 1 )) #This prints the current training set index on same line as an update stdout . flush () overall . append ( trial ) best_seq_perstate_permutnum [ str ( chosen_state )] = [] for muts in range ( L - mutation_threshold + 1 ): try : best_seq_perstate_permutnum [ str ( chosen_state )] . append ( max ( objective_func_sequence_dict [ 'Mutations_' + str ( muts )])) except ValueError : pass print ( ' \\n ' ) if self . display_plot and plot_separate : import matplotlib.pyplot as plt listt = [] for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): listt . append ([ i , best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . scatter ( states , probs ) plt . title ( 'Single State Optimization for State ' + str ( state_num )) if pdf_output_plot : pp . savefig () #plt.show() plt . close () if write_opt_file_name : for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): open ( opt_filename , 'a' ) . write ( str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]) + ',' + str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 1 ]) + ',' + str ( chosen_state ) + ',' + str ( 'num_Mutations = ' ) + str ( i ) + ' \\n ' ) if pdf_output_plot : pp . close () self . best_results = best_seq_perstate_permutnum if self . display_plot and plot_together : import matplotlib.pyplot as plt for stuff in best_seq_perstate_permutnum : listt = [] for i in range ( len ( best_seq_perstate_permutnum [ stuff ])): listt . append ([ i , best_seq_perstate_permutnum [ stuff ][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . title ( 'Log Shifted Probability Plot' + ' \\n ' + 'For Most Probable Sequence Per State Per Mutation Number' ) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Log of Probability' ) plt . scatter ( states , probs ) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return best_seq_perstate_permutnum","title":"Msm Model"},{"location":"msm_model_reference/#msm-model-module","text":"Created on Tue Oct 10 22:38:13 2017 @author: Trent","title":"msm model module"},{"location":"msm_model_reference/#msm_design.msm_model","text":"","title":"msm_model"},{"location":"msm_model_reference/#msm_design.msm_model.SGD_Online","text":"Source code in msm_design/msm_model.py class SGD_Online : def __init__ ( self , wt_seq , pdbfile , sequence_alignment_file = False , reduce_alignment = 2 , output_energy_file = False , custom_tag = False , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = .01 , ridge = False , ridge_coef = .01 , output_cc = True , output_mad = True , rosetta_score_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_database_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ): 'Takes in a pdb file, sequence alignment file, wild type sequence, and energy scoring script' 'We provide two scoring scripts score_sequence_amber.py and score_sequence_rosetta.py' 'The rosetta script requires rosetta protein structure software' 'The amber script requires openmm molecular modeling software as well as rosetta for energy minimization' 'this class must run in command line to make use of energy scoring scripts which output energies to command line' self . pdbfile = pdbfile self . pair_select_list = pair_select_list self . gamma_multiplier = gamma_multiplier self . wt_seq = wt_seq self . regular_linear_regression = regular_linear_regression self . lasso = lasso self . ridge = ridge self . lambda_lasso_coef = lambda_lasso_coef self . ridge_coef = ridge_coef self . output_energy_file = output_energy_file self . output_cc = output_cc self . output_mad = output_mad self . custom_tag = custom_tag self . overall_solution_space = None self . CC = None self . MAD = None self . model_parameters = None self . reduce_alignment = reduce_alignment self . pair_dist = pair_dist self . sequence_alignment_file = sequence_alignment_file self . rosetta_score_path = rosetta_score_path self . rosetta_database_path = rosetta_database_path def online_model ( self , energy_scoring_function = 'rosetta' , num_mutations = 4 , max_computation_time = 252000 , max_training_sets = 50000 , mad_cutoff = 1 , w_start_file = False ): #Scoring function is either 'rosetta' or 'amber' if not self . regular_linear_regression and not self . lasso and not self . ridge : raise ValueError ( 'No model type selected, one of regular_linear_regression, lasso, or ridge must be true' ) if self . regular_linear_regression and self . lasso : raise ValueError ( 'Cannot use both regular and lasso regression, select one or the other' ) if self . regular_linear_regression and self . ridge : raise ValueError ( 'Cannot use both regular and ridge regression, select one or the other' ) if self . ridge and self . lasso : raise ValueError ( 'Cannot use both ridge and lasso regression, select one or the other' ) if self . regular_linear_regression and self . lasso and self . ridge : raise ValueError ( 'Cannot use regular, ridge, and lasso regression at the same time, select one or the other' ) starttime = time . time () max_time = max_computation_time if w_start_file : hh = open ( w_start_file , 'r+' ) newtext = hh . read () newtext = newtext . split ( ' \\n ' ) del newtext [ - 1 ] w = [] for numbers in newtext : w . append ( float ( numbers )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] L = len ( wildtype ) overall_solution_space = import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) trainingsets = max_training_sets madcutoff = mad_cutoff #Here Creating the tag that follows to output files... #This is skipped if a custom_tag variable is defined if not self . custom_tag : if '/' in self . pdbfile : pdbtag = self . pdbfile . split ( '/' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if ' \\\\ ' in self . pdbfile : pdbtag = self . pdbfile . split ( ' \\\\ ' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if self . custom_tag : pdbtag = self . custom_tag print ( 'Filename Tag will be = ' + str ( pdbtag )) if self . output_energy_file : seqEfilename = 'ubiquitin_energies_' + str ( pdbtag ) + '.txt' # the length of the protein reference_seq = wtlist print ( reference_seq ) if self . pair_select_list : position_pairs = pair_select ( self . pdbfile , self . pair_dist , self . wt_seq ) else : position_pairs = [] #Definitions # Sample a random sequence, evaluate its energy according to our energy fucntion, and store the sequence and energy data E_list = [] CC = [] MAD = [] Philist = [] print ( 'Stochastic Gradient Descent' ) print ( '# of pair interactions = %s , %s maximum training sequences, gamma = %s /((i+1)**0.5)' % ( len ( position_pairs ), trainingsets , self . gamma_multiplier )) if self . output_energy_file : open ( seqEfilename , 'w' ) if self . output_cc : open ( 'CC' + str ( pdbtag ) + '.txt' , 'w' ) if self . output_mad : open ( 'MAD' + str ( pdbtag ) + '.txt' , 'w' ) for n in range ( trainingsets ): if time . time () - starttime < max_time : wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] randAAlist = [] for i in range ( num_mutations ): randAAlist . append ( random . randint ( 0 , L - 1 )) for mutantpositions in randAAlist : wtlist [ mutantpositions ] = choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( wtlist ) #cmd = 'python '+str(self.energy_scoring_script)+' %s' % random_seq #1. generate a terminal command as a string #output = Popen(cmd,shell=True,stdout=PIPE).communicate() #2. send the command to the terminal shell #seq_E = float(output[0]) #3. read the result and convert to a float 'Add a new energy scoring function here if wanted' 'Input should be random_seq and an associated pdbfile' 'Should create a definition similar to the two energy function definitions provided' 'if there is a need or want for a different energy function' if energy_scoring_function == 'amber' : seq_E = score_sequence_amber ( random_seq , pdbfile = self . pdbfile , rosetta_path = self . rosetta_score_path , rosetta_db = self . rosetta_database_path ) if energy_scoring_function == 'rosetta' : seq_E = score_sequence_rosetta ( random_seq , pdbfile = self . pdbfile , rosetta_path = self . rosetta_score_path , rosetta_db = self . rosetta_database_path ) #This bypasses Amber not returning scores for certain sequences if seq_E == 'Nan' : print ( 'Sequence did not generate a score' ) pass if seq_E != 'Nan' : #print(seq_E) seq_E = float ( seq_E ) #3. read the result and convert to a float print ( random_seq , seq_E ) if self . output_energy_file : open ( seqEfilename , 'a' ) . write ( random_seq + ',' + str ( seq_E ) + ' \\n ' ) E_list . append ( seq_E ) #Convert Seq to Phi Here seq_Phi = [ 1 ] for i in range ( L ): Phi_i = sigma2Phi ( random_seq [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) if self . pair_select_list : for pair in position_pairs : firstpos = pair [ 0 ] secondpos = pair [ 1 ] pairs_j = pairs ( random_seq [ firstpos ], random_seq [ secondpos ], firstpos , secondpos , overall_solution_space , reference_seq ) seq_Phi . extend ( pairs_j ) else : pass if len ( E_list ) - 1 < 100 : Philist . append ( seq_Phi ) if n == 0 : d = len ( seq_Phi ) if not w_start_file : w = numpy . zeros ( shape = ( d , 1 )) #Starting vector for regular regression not L1 if self . lasso : for f in range ( 1 , len ( Phi_i * L )): w [ f ][ 0 ] = .01 print ( 'Number of Variables in Model = ' + str ( d )) if len ( E_list ) - 1 >= 100 : Philist . append ( seq_Phi ) trainPhi = Philist [ 0 ] del Philist [ 0 ] E_testinglist = [ E_list [ - xx ] for xx in range ( 1 , 101 )] E_testinglist . reverse () trainE = E_list [ len ( E_list ) - 1 - 100 ] weight = 1 gamma = self . gamma_multiplier / (( n + 1 ) ** 0.5 ) # have to do plus one cause first round i = 0 x = numpy . array ([ trainPhi ]) . T # column vector if self . regular_linear_regression : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) #Ridge if self . ridge : w = w - gamma * ( x * weight * ( numpy . dot ( x . T , w ) * weight - trainE ) + self . ridge_coef * w ) #Lasso if self . lasso : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) for j in range ( d ): w [ j ][ 0 ] = STF ( w [ j ][ 0 ], gamma * self . lambda_lasso_coef ) E_estimate = numpy . empty ([ len ( Philist ), 1 ]) for s in range ( len ( Philist )): E_estimate [ s ] = numpy . dot ( Philist [ s ], w [:, 0 ]) E_estimate = E_estimate [:, 0 ] cc = numpy . corrcoef ( E_testinglist , E_estimate )[ 0 , 1 ] mad = numpy . mean ( abs ( E_estimate - E_testinglist )) print ( 'cc = ' + str ( cc )) print ( 'mad = ' + str ( mad )) CC . append ( cc ) # calculate the correlation coeffcient, append into list MAD . append ( mad ) # calculate the mean absolute deviation, append into list if self . output_cc : open ( 'CC' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( cc ) + ' \\n ' ) if self . output_mad : open ( 'MAD' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( mad ) + ' \\n ' ) madlist100 = [] if len ( MAD ) >= 100 : for g in range ( 1 , 101 ): madlist100 . append ( MAD [ - g ]) if all ( mm < float ( madcutoff ) for mm in madlist100 ): break open ( 'w' + str ( pdbtag ) + '.txt' , 'w' ) #open('wState0.txt','w') for vv in range ( len ( w )): open ( 'w' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( w [ vv ][ 0 ]) + ' \\n ' ) self . CC = CC self . MAD = MAD self . model_parameters = w print ( 'energy function fit:' ) print ( ' \\t CC = %0.2f ' % CC [( len ( MAD )) - 1 ]) print ( ' \\t MAD = %0.2f ' % MAD [( len ( MAD )) - 1 ]) #plt.scatter(E_testinglist,E_estimate) #plt.show() #Test to see how many features are zero... zerolist = [] for z in range ( len ( w )): if w [ z ][ 0 ] == 0 : zerolist . append ( z ) print ( 'Number of Features Equal to Zero in the Model = %s ' % len ( zerolist )) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return w","title":"SGD_Online"},{"location":"msm_model_reference/#msm_design.msm_model.SGD_Online.__init__","text":"Takes in a pdb file, sequence alignment file, wild type sequence, and energy scoring script Source code in msm_design/msm_model.py def __init__ ( self , wt_seq , pdbfile , sequence_alignment_file = False , reduce_alignment = 2 , output_energy_file = False , custom_tag = False , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = .01 , ridge = False , ridge_coef = .01 , output_cc = True , output_mad = True , rosetta_score_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_database_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ): 'Takes in a pdb file, sequence alignment file, wild type sequence, and energy scoring script' 'We provide two scoring scripts score_sequence_amber.py and score_sequence_rosetta.py' 'The rosetta script requires rosetta protein structure software' 'The amber script requires openmm molecular modeling software as well as rosetta for energy minimization' 'this class must run in command line to make use of energy scoring scripts which output energies to command line' self . pdbfile = pdbfile self . pair_select_list = pair_select_list self . gamma_multiplier = gamma_multiplier self . wt_seq = wt_seq self . regular_linear_regression = regular_linear_regression self . lasso = lasso self . ridge = ridge self . lambda_lasso_coef = lambda_lasso_coef self . ridge_coef = ridge_coef self . output_energy_file = output_energy_file self . output_cc = output_cc self . output_mad = output_mad self . custom_tag = custom_tag self . overall_solution_space = None self . CC = None self . MAD = None self . model_parameters = None self . reduce_alignment = reduce_alignment self . pair_dist = pair_dist self . sequence_alignment_file = sequence_alignment_file self . rosetta_score_path = rosetta_score_path self . rosetta_database_path = rosetta_database_path","title":"__init__()"},{"location":"msm_model_reference/#msm_design.msm_model.SGD_Static","text":"Test header Attributes: Name Type Description scored bool test score arg Returns: list \u2013 test list return Examples: >>> data = SGD_Static () >>> output = data . do_something () Source code in msm_design/msm_model.py class SGD_Static : \"\"\" Test header Attributes: scored (bool): test score arg Returns: list: test list return Example: >>> data = SGD_Static() >>> output = data.do_something() \"\"\" def __init__ ( self , pdbfile , sequence_energy_file , wt_seq , sequence_alignment_file = False , reduce_alignment = 1 , pair_select_list = False , pair_dist = 4 , gamma_multiplier = 2 , regular_linear_regression = True , lasso = False , lambda_lasso_coef = .01 , ridge = False , ridge_coef = .01 , custom_tag = False ): self . pdbfile = pdbfile self . sequence_energy_file = sequence_energy_file self . sequence_alignment_file = sequence_alignment_file self . pair_select_list = pair_select_list self . gamma_multiplier = gamma_multiplier self . wt_seq = wt_seq self . regular_linear_regression = regular_linear_regression self . lasso = lasso self . ridge = ridge self . lambda_lasso_coef = lambda_lasso_coef self . ridge_coef = ridge_coef self . custom_tag = custom_tag self . overall_solution_space = None self . energies = None self . sequences = None self . CC = None self . MAD = None self . model_parameters = None self . pair_dist = pair_dist self . reduce_alignment = reduce_alignment def static_model ( self , mad_thresh = .01 , model_output_text_file = False , display_plots = True ): if not self . regular_linear_regression and not self . lasso and not self . ridge : raise ValueError ( 'No model type selected, one of regular_linear_regression, lasso, or ridge must be true' ) if self . regular_linear_regression and self . lasso : raise ValueError ( 'Cannot use both regular and lasso regression, select one or the other' ) if self . regular_linear_regression and self . ridge : raise ValueError ( 'Cannot use both regular and ridge regression, select one or the other' ) if self . ridge and self . lasso : raise ValueError ( 'Cannot use both ridge and lasso regression, select one or the other' ) if self . regular_linear_regression and self . lasso and self . ridge : raise ValueError ( 'Cannot use regular, ridge, and lasso regression at the same time, select one or the other' ) starttime = time . time () #max_time = 252000 max_time = 5000000 start_time = time . time () if not self . custom_tag : if '/' in self . pdbfile : pdbtag = self . pdbfile . split ( '/' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if ' \\\\ ' in self . pdbfile : pdbtag = self . pdbfile . split ( ' \\\\ ' )[ - 1 ] . split ( '.' )[ 0 ] else : pdbtag = self . pdbfile if self . custom_tag : pdbtag = self . custom_tag print ( 'Filename Tag will be = ' + str ( pdbtag )) L = len ( self . wt_seq ) # the length of the protein overall_solution_space = import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) #wildtype = 'MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG' wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) h = open ( self . sequence_energy_file , 'r+' ) text = h . read () text = text . split ( ' \\n ' ) del text [ - 1 ] sequences = [ t . split ( ',' )[ 0 ] for t in text ] Energies = [ float ( t . split ( ',' )[ 1 ]) for t in text ] self . sequences = sequences self . energies = Energies if self . pair_select_list : position_pairs = pair_select ( self . pdbfile , self . pair_dist , self . wt_seq ) else : position_pairs = [] # Sample a random sequence, evaluate its energy according to our energy fucntion, and store the sequence and energy data trainingsets = len ( Energies ) print ( 'Number of training sets = ' + str ( len ( Energies ))) E_list = [] random_Seq_list = [] CC = [] MAD = [] #w = [] Philist = [] trainE = [] trainPhi = [] print ( 'Stochastic Gradient Descent Multivariate Linear Regression' ) print ( '# of pair interactions = %s , gamma = %s /((i+1)**0.5)' % ( len ( position_pairs ), self . gamma_multiplier )) print ( ' \\n ' ) for n in range ( trainingsets ): if time . time () - start_time < max_time : random_Seq_list . append ( sequences [ n ]) E_list . append ( Energies [ n ]) #Convert Seq to Phi Here seq_Phi = [ 1 ] for i in range ( L ): Phi_i = sigma2Phi ( random_Seq_list [ n ][ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) if self . pair_select_list : for pair in position_pairs : firstpos = pair [ 0 ] secondpos = pair [ 1 ] pairs_j = pairs ( random_Seq_list [ n ][ firstpos ], random_Seq_list [ n ][ secondpos ], firstpos , secondpos , overall_solution_space , reference_seq ) seq_Phi . extend ( pairs_j ) else : pass if n < 100 : Philist . append ( seq_Phi ) if n == 0 : d = len ( seq_Phi ) w = numpy . zeros ( shape = ( d , 1 )) #Starting vector for regular regression not L1 if self . lasso : for f in range ( 1 , len ( Phi_i * L )): w [ f ][ 0 ] = .01 print ( 'Number of Variables in Model = ' + str ( d )) if n >= 100 : Philist . append ( seq_Phi ) trainPhi = Philist [ 0 ] del Philist [ 0 ] E_testinglist = [ E_list [ - xx ] for xx in range ( 1 , 101 )] E_testinglist . reverse () trainE = E_list [ n - 100 ] weight = 1 gamma = self . gamma_multiplier / (( n - 100 + 1 ) ** 0.5 ) x = numpy . array ([ trainPhi ]) . T # column vector if self . regular_linear_regression : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) #Ridge if self . ridge : w = w - gamma * ( x * weight * ( numpy . dot ( x . T , w ) * weight - trainE ) + self . ridge_coef * w ) #Lasso if self . lasso : w = w - gamma * x * weight * ( numpy . dot ( x . T , w ) * weight - trainE * weight ) for j in range ( d ): w [ j ][ 0 ] = STF ( w [ j ][ 0 ], gamma * self . lambda_lasso_coef ) # analyze the fit of the current model w #Regular Matrix Multiplication E_estimate = numpy . empty ([ len ( Philist ), 1 ]) for s in range ( len ( Philist )): E_estimate [ s ] = numpy . dot ( Philist [ s ], w [:, 0 ]) E_estimate = E_estimate [:, 0 ] cc = numpy . corrcoef ( E_testinglist , E_estimate )[ 0 , 1 ] mad = numpy . mean ( abs ( E_estimate - E_testinglist )) CC . append ( cc ) # calculate the correlation coeffcient, append into list MAD . append ( float ( mad )) # calculate the mean absolute deviation, append into list stdout . write ( ' \\r Training set = %s ' % str ( n + 1 )) #This prints the current training set index on same line as an update stdout . flush () madlist100 = [] if len ( MAD ) >= 100 : for g in range ( 1 , 101 ): madlist100 . append ( MAD [ - g ]) if all ( mm < float ( mad_thresh ) for mm in madlist100 ): break if model_output_text_file : open ( 'w' + str ( pdbtag ) + '.txt' , 'w' ) for vv in range ( len ( w )): open ( 'w' + str ( pdbtag ) + '.txt' , 'a' ) . write ( str ( w [ vv ][ 0 ]) + ' \\n ' ) self . CC = CC self . MAD = MAD self . model_parameters = w if display_plots : import matplotlib.pyplot as plt plt . plot ( range ( len ( MAD )), MAD ) plt . show () plt . plot ( range ( len ( CC )), CC ) plt . show () plt . scatter ( E_testinglist , E_estimate ) plt . show () print ( 'energy function fit:' ) print ( ' \\t CC = %0.2f ' % CC [( len ( MAD )) - 1 ]) print ( ' \\t MAD = %0.2f ' % MAD [( len ( MAD )) - 1 ]) #Test to see how many features are zero... zerolist = [] for z in range ( len ( w )): if w [ z ][ 0 ] == 0 : zerolist . append ( z ) print ( 'Number of Features Equal to Zero in the Model = %s ' % len ( zerolist )) sumlist = [] for i in range ( 1000 ): sumlist . append ( MAD [ - i ]) print ( 'Avg MAD of last 1000 terms = ' + str ( sum ( sumlist ) / 1000 )) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return w","title":"SGD_Static"},{"location":"msm_model_reference/#msm_design.msm_model.pair_select","text":"Here we select the maximum distance for a pair of AAs to be considered important Source code in msm_design/msm_model.py def pair_select ( pdbfile , dist , wt_seq ): \"Here we select the maximum distance for a pair of AAs to be considered important\" angstrom_distance = dist ######################################################################### #this should really use the 'state' pdb files.... L = len ( wt_seq ) #AAs = ['A', 'C', 'D', 'E', 'F', 'G', 'H','I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W','Y'] #all 20 amino acids pdbdata = open ( pdbfile ) . read () pdblines = pdbdata . split ( ' \\n ' ) coordinates = [] for line in pdblines : if line [: 4 ] == 'ATOM' : coordinates . append ( line ) #\"Why is there a lot of extra sequences in the pdb file\" #for i in range(4123): # coordinates.pop() \"Here we make lists of all atoms x,y,z coordinates and pair them by which AA they are in into lists, each list corresponds to the atoms in each AA\" xcoors = {} for q in range ( 1 , L + 1 ): xcoors [ 'AAxcoor' + str ( q )] = [] for j in range ( L + 1 ): for line in coordinates : if int ( line [ 22 : 26 ]) == j : x = line [ 30 : 38 ] xnum = float ( x ) xcoors [ 'AAxcoor' + str ( j )] . append ( xnum ) ycoors = {} for q in range ( 1 , L + 1 ): ycoors [ 'AAycoor' + str ( q )] = [] for k in range ( L + 1 ): for line in coordinates : if int ( line [ 22 : 26 ]) == k : y = line [ 38 : 46 ] ynum = float ( y ) ycoors [ 'AAycoor' + str ( k )] . append ( ynum ) zcoors = {} for q in range ( 1 , L + 1 ): zcoors [ 'AAzcoor' + str ( q )] = [] for s in range ( L + 1 ): for line in coordinates : if int ( line [ 22 : 26 ]) == s : z = line [ 46 : 54 ] znum = float ( z ) zcoors [ 'AAzcoor' + str ( s )] . append ( znum ) \"Pair all xyz together\" listofxyz = {} for q in range ( 1 , L + 1 ): listofxyz [ 'listofxyz' + str ( q )] = [] \"XYZ points of all atoms sorted into lists of corresponding AAs\" for q in range ( 1 , L + 1 ): for j in range ( len ( xcoors [ 'AAxcoor' + str ( q )])): listofxyz [ 'listofxyz' + str ( q )] . append (( xcoors [ 'AAxcoor' + str ( q )][ j ], ycoors [ 'AAycoor' + str ( q )][ j ], zcoors [ 'AAzcoor' + str ( q )][ j ])) \"Here we find the distance between every atom in the protein separated by the atoms that belong to specific AAs\" atomtoatom = {} for i in range ( 1 , L + 1 ): for j in range ( 1 , L + 1 ): if i < j : atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )] = [] for k in range ( len ( listofxyz [ 'listofxyz' + str ( i )])): for f in range ( len ( listofxyz [ 'listofxyz' + str ( j )])): atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )] . append ( numpy . linalg . norm ( numpy . array ( listofxyz [ 'listofxyz' + str ( i )])[ k ] - numpy . array ( listofxyz [ 'listofxyz' + str ( j )])[ f ])) \"Here we take the minimum distance between atoms between all AAs\" minimumdistances = {} for i in range ( 1 , L + 1 ): for j in range ( 1 , L + 1 ): if i < j and atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )] != []: #New shit here... minimumdistances [ 'minimumdistances' + str ( i ) + '-' + str ( j )] = [] minimumdistances [ 'minimumdistances' + str ( i ) + '-' + str ( j )] = min ( atomtoatom [ 'atomtoatom' + str ( i ) + '-' + str ( j )]) \"Here we determine which pairs are close enough by setting an angstrom_distance constraint\" closeatoms = [] for i in range ( 1 , L + 1 ): for j in range ( 1 , L + 1 ): if all ([ i < j and minimumdistances [ 'minimumdistances' + str ( i ) + '-' + str ( j )] < float ( angstrom_distance )]): #if all([i<j and minimumdistances['minimumdistances'+str(i)+'-'+str(j)]<float(angstrom_distance) and abs(i-j)!=1]): closeatoms . append (( i , j )) \"Here we subtract of (1,1) from each pair to match the indecies of the regression format\" newcloseatoms = numpy . array ( closeatoms ) - ( 1 , 1 ) newcloseatoms = map ( tuple , newcloseatoms ) print ( len ( newcloseatoms )) return newcloseatoms","title":"pair_select()"},{"location":"msm_model_reference/#msm_design.msm_model.score_sequence_amber","text":"Provide rosetta path to fixbb.linuxgccrelease Source code in msm_design/msm_model.py def score_sequence_amber ( newseq = None , pdbfile = None , rosetta_path = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/source/bin/' , rosetta_db = '/home/romeroroot/code/rosetta_src_2016.17.58663_bundle/main/database' ): 'Provide rosetta path to fixbb.linuxgccrelease' from random import choice from os import remove import simtk.openmm.app as app import simtk.openmm as op import simtk.unit as unit def rand_tag (): '''creates a unique tag that can be used to identify the current files a script is working with. necessary for running the same program multiple times in the same directory''' alpha = 'abcdefghijklmnopqrstuvwxyz0123456789' tag = '' . join ([ choice ( alpha ) for i in range ( 15 )]) return tag def thread_repack_score_amber ( pdbfile , newseq ): tag = rand_tag () # generate a random tag to associate with this run # generate a resfile to mutate the pdb resfile = \"\"\" #header NATAA # keep this so all sites aren't designed USE_INPUT_SC # this to also consider the WT rotamer, if we're mutating WT to WT start #body \\n \"\"\" for i in range ( len ( newseq )): resfile += ' %i A PIKAA %s \\n ' % ( i + 1 , newseq [ i ]) open ( 'resfile_' + tag + '.res' , 'w' ) . write ( resfile ) # the options for the run options = [ 'nice' , rosetta_path + 'fixbb.linuxgccrelease' , # fixbb is the program used for threading a repacking '-s ' + pdbfile , '-database ' + rosetta_db , # good to explicitly define location of rosetta DB '-resfile resfile_' + tag + '.res' , # a resfile to specify mutations '-out:suffix _' + tag ] # this adds a suffix to the score output file: score_[RNDTAG].sc # run fixbb Popen ( options , stdout = open ( '/dev/null' , 'w' )) . wait () # send stdout to the trash, report stderr # read the output scorefile = open ( 'score_ %s .sc' % tag ) . read () . split ( ' \\n ' ) names = scorefile [ 1 ] . split ( ':' )[ 1 ] . split () values = scorefile [ 2 ] . split ( ':' )[ 1 ] . split () score = dict (( names [ i ], float ( values [ i ])) for i in range ( len ( names ) - 1 )) # use i-1 because the last entry is the filename pdbname = ( pdbfile [: - 4 ] + '_' + tag + '_0001.pdb' ) . split ( '/' )[ - 1 ] # now load into openMM and score with amber pdb = app . PDBFile ( pdbname ) forcefield = app . ForceField ( 'amber03.xml' , 'amber03_obc.xml' ) system = forcefield . createSystem ( pdb . topology , nonbondedMethod = app . NoCutoff , constraints = None ) integrator = op . LangevinIntegrator ( 300 * unit . kelvin , 1 / unit . picosecond , 1e-9 * unit . picoseconds ) simulation = app . Simulation ( pdb . topology , system , integrator ) simulation . context . setPositions ( pdb . positions ) #Must do try/except here because Amber occasionally throws an Exception error and does not return a score try : simulation . minimizeEnergy () state = simulation . context . getState ( getPositions = True , getEnergy = True ) score = state . getPotentialEnergy () / unit . kilojoule_per_mole except Exception : score = 'Nan' pass #delete the evidence remove ( 'score_ %s .sc' % tag ) remove ( 'resfile_' + tag + '.res' ) remove ( pdbname ) return score score = thread_repack_score_amber ( pdbfile , newseq ) return score","title":"score_sequence_amber()"},{"location":"msm_model_reference/#msm_design.msm_model.sigma2Phi","text":"This takes in an amino acid and a position and returns the 1x19 binary indicator vector Phi Source code in msm_design/msm_model.py def sigma2Phi ( sigma , i , overall_solution_space , reference_seq ): \"\"\"This takes in an amino acid and a position and returns the 1x19 binary indicator vector Phi\"\"\" AAchanges = [ aa for aa in overall_solution_space [ i ] if aa != reference_seq [ i ]] # these are all 19 possible AA changes (i.e. AAs that are not the reference sequence AA) #AAchanges = [aa for aa in AAs if aa!=reference_seq[i]] Phi = [] for aa in AAchanges : if sigma == aa : Phi . append ( 1 ) else : Phi . append ( 0 ) return Phi","title":"sigma2Phi()"},{"location":"msm_model_reference/#msm_design.msm_optimization","text":"Created on Wed Jan 18 23:26:11 2017 @author: Trent","title":"msm_optimization"},{"location":"msm_model_reference/#msm_design.msm_optimization.Sequence_Optimization","text":"Source code in msm_design/msm_optimization.py class Sequence_Optimization : def __init__ ( self , model_file_dir , wt_seq , sequence_alignment_file = False , reduce_alignment = 1 , mad_file_dir = False , cc_file_dir = False , display_plot = True , pair_interaction_dist = False , pdb_dir = False ): self . model_file_dir = model_file_dir self . mad_file_dir = mad_file_dir self . cc_file_dir = cc_file_dir self . wt_seq = wt_seq self . sequence_alignment_file = sequence_alignment_file self . display_plot = display_plot self . best_results = None self . reduce_alignment = reduce_alignment # if pair_interaction_dist and pdb_dir: # # pair_interaction_list=Msm_Design.pair_select(pdbfile,pair_interaction_dist,wt_seq) # self.pair_interaction_list = pair_interaction_list def import_model_files ( self ): newfilelist = os . listdir ( self . model_file_dir ) newnamelist = [] for newnames in newfilelist : newnamelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) wStates = {} for q in range ( len ( newfilelist )): wStates [ 'wState' + str ( newnamelist [ q ])] = [] for j in range ( len ( newfilelist )): hh = open ( self . model_file_dir + str ( newfilelist [ j ]), 'r+' ) newtext = hh . read () newtext = newtext . split ( ' \\n ' ) del newtext [ - 1 ] newfloatedlist = [] for numbers in newtext : newfloatedlist . append ( float ( numbers )) wStates [ 'wState' + str ( newnamelist [ j ])] = numpy . array ( newfloatedlist ) return wStates def test_model_performance ( self ): if self . mad_file_dir : filelist = os . listdir ( self . mad_file_dir ) #print filelist namelist = [] for names in filelist : namelist . append ( re . sub ( \"[^0-9]\" , '' , names )) MADStates = {} for q in range ( len ( filelist )): MADStates [ 'MADState' + str ( namelist [ q ])] = [] sumlist = [] for j in range ( len ( filelist )): h = open ( self . mad_file_dir + str ( filelist [ j ]), 'r+' ) text = h . read () text = text . split ( ' \\n ' ) #text = pickle.load(open('seq_energies_state0_ubiquitin.p')) del text [ - 1 ] floatedlist = [] for items in text : try : floatedlist . append ( float ( items )) except ValueError : pass if floatedlist != []: MADStates [ 'MADState' + str ( namelist [ j ])] = floatedlist thousandlist = [] if len ( floatedlist ) < 1000 : for i in range ( len ( floatedlist )): thousandlist . append ( floatedlist [ i ]) sumlist . append ( sum ( thousandlist ) / len ( thousandlist )) if len ( floatedlist ) >= 1000 : for i in range ( 1 , 1001 ): thousandlist . append ( floatedlist [ - i ]) sumlist . append ([ sum ( thousandlist ) / 1000 ]) sumlist [ - 1 ] . append ( str ( filelist [ j ])) print ( sumlist ) return sumlist else : print ( 'No MAD Directory Set' ) def generate_seq_energy ( self , seq , state_number ): 'Pair models not yet supported' wStates = self . import_model_files () overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , len ( self . wt_seq )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( len ( self . wt_seq )): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(lowESeqtest[n][firstpos],lowESeqtest[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi rnd_list = [] for j in range ( len ( seq )): if seq [ j ] not in overall_solution_space [ j ]: print ( 'Residue ' + str ( seq [ j ]) + ' at position ' + str ( j ) + ' not in amino acid space ' + str ( overall_solution_space [ j ])) rnd_list . append ( j ) break if len ( rnd_list ) <= 0 : binary_seq = binary_conversion ( seq ) energy = numpy . dot ( binary_seq , wStates [ 'wState' + str ( state_number )]) return energy def single_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 8.31447e-3 , mut_thresh = 10 , num_mutation_pathway_passes = 500 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ): 'Pair distances not supported' mutation_threshold = len ( self . wt_seq ) - mut_thresh starttime = time . time () if self . mad_file_dir : print ( self . test_model_performance ()) else : pass wStates = self . import_model_files () modelsfiles = os . listdir ( self . model_file_dir ) modelsfilelist = [] for newnames in modelsfiles : modelsfilelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) L = len ( self . wt_seq ) # this is the amino acids allowed at each postion overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( L ): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(sequence[n][firstpos],sequence[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi def single_probability_estimation ( binary , State_to_optimize , mean ): E_estimate = math . exp ( - ( numpy . dot ( binary , wStates [ 'w' + str ( State_to_optimize )]) - mean ) / ( k * t )) return E_estimate def multi_probability_estimation ( binary , mean ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_estimate_mult = math . exp ( - ( numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) - mean ) / ( k * t )) State_E_list . append ( E_estimate_mult ) return sum ( State_E_list ) def energy_mean_calc ( binary ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_mult = numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) State_E_list . append ( E_mult ) return numpy . mean ( State_E_list ) if write_opt_file_name : opt_filename = write_opt_file_name open ( opt_filename , 'w' ) open ( opt_filename , 'a' ) . write ( 'Probability' + ',' + str ( 'Sequence' ) + ',' + str ( 'chosen_state' ) + ' \\n ' ) #state_opt = ['State12'] #Might need to take out WT mutations from overall_solution_space to avoid mutating to wt best_seq_perstate_permutnum = {} if pdf_output_plot : from matplotlib.backends.backend_pdf import PdfPages pp = PdfPages ( pdf_output_plot ) for state_num in states_to_optimize_for_by_state_number : chosen_state = 'State' + str ( state_num ) print ( chosen_state ) rand_seq_list = [] boltz_list = [] objective_func_sequence_dict = {} for muts in range ( L - mutation_threshold + 1 ): objective_func_sequence_dict [ 'Mutations_' + str ( muts )] = [] #Test Optimization overall = [] for nn in range ( num_mutation_pathway_passes ): trial = [] for n in range ( inner_loop_trials ): if len ( trial ) <= mut_thresh : if n == 0 : aminoacidchain = [ wildtype [ i ] for i in range ( len ( wildtype ))] random_seq = '' . join ( aminoacidchain ) rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( random_seq ) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , random_seq ]) trial . append ( boltz_dist ) if n > 0 : randAAlist = [] for i in range ( 1 ): randAAlist . append ( random . randint ( 0 , L - 1 )) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : aachaintobemutated = list ( aminoacidchain ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : aachaintobemutated = list ( rand_seq_list [ - 1 ]) for mutantpositions in randAAlist : aachaintobemutated [ mutantpositions ] = random . choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( aachaintobemutated ) listseq = list ( random_seq ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : rand_seq_list . append ( listseq ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) if boltz_list [ - 1 ] > boltz_list [ - 2 ]: trial . append ( boltz_dist ) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , '' . join ( listseq )]) pass if boltz_list [ - 1 ] <= boltz_list [ - 2 ]: del rand_seq_list [ - 1 ] del boltz_list [ - 1 ] stdout . write ( ' \\r Mutation Pathway Number = %s ' % str ( nn + 1 )) #This prints the current training set index on same line as an update stdout . flush () overall . append ( trial ) best_seq_perstate_permutnum [ str ( chosen_state )] = [] for muts in range ( L - mutation_threshold + 1 ): try : best_seq_perstate_permutnum [ str ( chosen_state )] . append ( max ( objective_func_sequence_dict [ 'Mutations_' + str ( muts )])) except ValueError : pass print ( ' \\n ' ) if self . display_plot and plot_separate : import matplotlib.pyplot as plt listt = [] for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): listt . append ([ i , best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . scatter ( states , probs ) plt . title ( 'Single State Optimization for State ' + str ( state_num )) if pdf_output_plot : pp . savefig () #plt.show() plt . close () if write_opt_file_name : for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): open ( opt_filename , 'a' ) . write ( str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]) + ',' + str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 1 ]) + ',' + str ( chosen_state ) + ',' + str ( 'num_Mutations = ' ) + str ( i ) + ' \\n ' ) if pdf_output_plot : pp . close () self . best_results = best_seq_perstate_permutnum if self . display_plot and plot_together : import matplotlib.pyplot as plt for stuff in best_seq_perstate_permutnum : listt = [] for i in range ( len ( best_seq_perstate_permutnum [ stuff ])): listt . append ([ i , best_seq_perstate_permutnum [ stuff ][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . title ( 'Log Shifted Probability Plot' + ' \\n ' + 'For Most Probable Sequence Per State Per Mutation Number' ) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Log of Probability' ) plt . scatter ( states , probs ) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return best_seq_perstate_permutnum def two_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 8.31447e-3 , mut_thresh = 10 , num_mutation_pathway_passes = 100 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ): mutation_threshold = len ( self . wt_seq ) - mut_thresh starttime = time . time () if self . mad_file_dir : print ( self . test_model_performance ()) else : pass wStates = self . import_model_files () modelsfiles = os . listdir ( self . model_file_dir ) modelsfilelist = [] for newnames in modelsfiles : modelsfilelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) L = len ( self . wt_seq ) # this is the amino acids allowed at each postion overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , len ( self . wt_seq )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( L ): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(lowESeqtest[n][firstpos],lowESeqtest[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi def single_probability_estimation ( binary , State_to_optimize , mean ): E_estimate = math . exp ( - ( numpy . dot ( binary , wStates [ 'w' + str ( State_to_optimize )]) - mean ) / ( k * t )) return E_estimate def multi_probability_estimation ( binary , mean ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_estimate_mult = math . exp ( - ( numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) - mean ) / ( k * t )) State_E_list . append ( E_estimate_mult ) return sum ( State_E_list ) def energy_mean_calc ( binary ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_mult = numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) State_E_list . append ( E_mult ) return numpy . mean ( State_E_list ) if write_opt_file_name : opt_filename = write_opt_file_name open ( opt_filename , 'w' ) open ( opt_filename , 'a' ) . write ( 'Objective_Function_Value' + ',' + str ( 'Sequence' ) + ',' + str ( 'chosen_state1' ) + ',' + str ( 'chosen_state2' ) + ' \\n ' ) best_seq_perstate_permutnum = {} if pdf_output_plot : from matplotlib.backends.backend_pdf import PdfPages pp = PdfPages ( pdf_output_plot ) #Might need to take out WT mutations from overall_solution_space to avoid mutating to wt #Test Optimization for jj in range ( len ( states_to_optimize_for_by_state_number )): state_num1 = states_to_optimize_for_by_state_number [ jj ][ 0 ] state_num2 = states_to_optimize_for_by_state_number [ jj ][ 1 ] chosen_state1 = 'State' + str ( state_num1 ) chosen_state2 = 'State' + str ( state_num2 ) print ( chosen_state1 ) print ( chosen_state2 ) two_state_opt_list = [] boltz_list1 = [] boltz_list2 = [] rand_seq_list = [] objective_func_sequence_dict = {} for muts in range ( L - mutation_threshold + 1 ): objective_func_sequence_dict [ 'Mutations_' + str ( muts )] = [] overall = [] for nn in range ( num_mutation_pathway_passes ): trial = [] for n in range ( inner_loop_trials ): if len ( trial ) <= mut_thresh : if n == 0 : aminoacidchain = [ wildtype [ i ] for i in range ( len ( wildtype ))] random_seq = '' . join ( aminoacidchain ) rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( random_seq ) mean_energy = energy_mean_calc ( Phi ) single_E1 = single_probability_estimation ( Phi , chosen_state1 , mean_energy ) single_E2 = single_probability_estimation ( Phi , chosen_state2 , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist1 = single_E1 / multi_E boltz_dist2 = single_E2 / multi_E boltz_list1 . append ( boltz_dist1 ) boltz_list2 . append ( boltz_dist2 ) opt_func = ( boltz_dist1 - .5 ) ** 2 + ( boltz_dist2 - .5 ) ** 2 two_state_opt_list . append ( opt_func ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ opt_func , '' . join ( aminoacidchain ), boltz_dist1 , boltz_dist2 ]) trial . append ( opt_func ) if n > 0 : randAAlist = [] for i in range ( 1 ): randAAlist . append ( random . randint ( 0 , L - 1 )) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : aachaintobemutated = list ( aminoacidchain ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : aachaintobemutated = list ( rand_seq_list [ - 1 ]) for mutantpositions in randAAlist : aachaintobemutated [ mutantpositions ] = random . choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( aachaintobemutated ) listseq = list ( random_seq ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) mean_energy = energy_mean_calc ( Phi ) single_E1 = single_probability_estimation ( Phi , chosen_state1 , mean_energy ) single_E2 = single_probability_estimation ( Phi , chosen_state2 , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist1 = single_E1 / multi_E boltz_dist2 = single_E2 / multi_E boltz_list1 . append ( boltz_dist1 ) boltz_list2 . append ( boltz_dist2 ) opt_func = ( boltz_dist1 - .5 ) ** 2 + ( boltz_dist2 - .5 ) ** 2 two_state_opt_list . append ( opt_func ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : rand_seq_list . append ( listseq ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) mean_energy = energy_mean_calc ( Phi ) single_E1 = single_probability_estimation ( Phi , chosen_state1 , mean_energy ) single_E2 = single_probability_estimation ( Phi , chosen_state2 , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist1 = single_E1 / multi_E boltz_dist2 = single_E2 / multi_E boltz_list1 . append ( boltz_dist1 ) boltz_list2 . append ( boltz_dist2 ) opt_func = ( boltz_dist1 - .5 ) ** 2 + ( boltz_dist2 - .5 ) ** 2 two_state_opt_list . append ( opt_func ) Mut_num = 76 - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) if ( boltz_list1 [ - 1 ] > boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] > boltz_list2 [ - 2 ]): #if two_state_opt_list[-1]<=two_state_opt_list[-2]: trial . append ( opt_func ) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ opt_func , '' . join ( listseq ), boltz_dist1 , boltz_dist2 ]) pass if ( boltz_list1 [ - 1 ] <= boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] <= boltz_list2 [ - 2 ]) or ( boltz_list1 [ - 1 ] > boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] <= boltz_list2 [ - 2 ]) or ( boltz_list1 [ - 1 ] <= boltz_list1 [ - 2 ] and boltz_list2 [ - 1 ] > boltz_list2 [ - 2 ]): #if two_state_opt_list[-1]>two_state_opt_list[-2]: del rand_seq_list [ - 1 ] del two_state_opt_list [ - 1 ] del boltz_list1 [ - 1 ] del boltz_list2 [ - 1 ] stdout . write ( ' \\r Mutation Pathway Number = %s ' % str ( nn + 1 )) #This prints the current training set index on same line as an update stdout . flush () print ( ' \\n ' ) overall . append ( trial ) best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )] = [] for muts in range ( L - mutation_threshold + 1 ): best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )] . append ( min ( objective_func_sequence_dict [ 'Mutations_' + str ( muts )])) if self . display_plot and plot_separate : import matplotlib.pyplot as plt listt = [] for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )])): listt . append ([ i , best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ x [ 1 ] for x in listt ] plt . scatter ( states , probs ) plt . title ( 'Two State Optimization for State' + str ( state_num1 ) + ' and State' + str ( state_num2 )) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Objective Function Value' ) if pdf_output_plot : pp . savefig () #plt.show() plt . close () if write_opt_file_name : for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )])): open ( opt_filename , 'a' ) . write ( str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 0 ]) + ',' + str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 1 ]) + ',' + str ( chosen_state1 ) + '_probability=' + str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 2 ]) + ',' + str ( chosen_state2 ) + '_probability=' + str ( best_seq_perstate_permutnum [ str ( chosen_state1 ) + '_' + str ( chosen_state2 )][ i ][ 3 ]) + ',' + str ( 'num_Mutations=' ) + str ( i ) + ' \\n ' ) if pdf_output_plot : pp . close () if self . display_plot and plot_together : import matplotlib.pyplot as plt for stuff in best_seq_perstate_permutnum : listt = [] for i in range ( len ( best_seq_perstate_permutnum [ stuff ])): listt . append ([ i , best_seq_perstate_permutnum [ stuff ][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ x [ 1 ] for x in listt ] plt . scatter ( states , probs ) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Objective Function Value' ) plt . title ( 'Two State Optimization for All Defined Pairs of States' ) self . best_results = best_seq_perstate_permutnum print ( ' \\n ' ) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime )","title":"Sequence_Optimization"},{"location":"msm_model_reference/#msm_design.msm_optimization.Sequence_Optimization.generate_seq_energy","text":"Pair models not yet supported Source code in msm_design/msm_optimization.py def generate_seq_energy ( self , seq , state_number ): 'Pair models not yet supported' wStates = self . import_model_files () overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , len ( self . wt_seq )) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( len ( self . wt_seq )): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(lowESeqtest[n][firstpos],lowESeqtest[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi rnd_list = [] for j in range ( len ( seq )): if seq [ j ] not in overall_solution_space [ j ]: print ( 'Residue ' + str ( seq [ j ]) + ' at position ' + str ( j ) + ' not in amino acid space ' + str ( overall_solution_space [ j ])) rnd_list . append ( j ) break if len ( rnd_list ) <= 0 : binary_seq = binary_conversion ( seq ) energy = numpy . dot ( binary_seq , wStates [ 'wState' + str ( state_number )]) return energy","title":"generate_seq_energy()"},{"location":"msm_model_reference/#msm_design.msm_optimization.Sequence_Optimization.single_state_design","text":"Pair distances not supported Source code in msm_design/msm_optimization.py def single_state_design ( self , states_to_optimize_for_by_state_number , t = 298.15 , k = 8.31447e-3 , mut_thresh = 10 , num_mutation_pathway_passes = 500 , inner_loop_trials = 1000 , mean_shift = True , plot_separate = True , plot_together = False , pdf_output_plot = False , write_opt_file_name = False ): 'Pair distances not supported' mutation_threshold = len ( self . wt_seq ) - mut_thresh starttime = time . time () if self . mad_file_dir : print ( self . test_model_performance ()) else : pass wStates = self . import_model_files () modelsfiles = os . listdir ( self . model_file_dir ) modelsfilelist = [] for newnames in modelsfiles : modelsfilelist . append ( re . sub ( \"[^0-9]\" , '' , newnames )) L = len ( self . wt_seq ) # this is the amino acids allowed at each postion overall_solution_space = msm_model . import_sequence_alignment ( self . sequence_alignment_file , self . reduce_alignment , L ) print ( overall_solution_space ) wildtype = self . wt_seq wtlist = [ wildtype [ i ] for i in range ( len ( wildtype ))] reference_seq = wtlist print ( reference_seq ) def binary_conversion ( sequence ): seq_Phi = [ 1 ] for i in range ( L ): Phi_i = msm_model . sigma2Phi ( sequence [ i ], i , overall_solution_space , reference_seq ) seq_Phi . extend ( Phi_i ) # for pair in position_pairs: # firstpos = pair[0] # secondpos = pair[1] # pairs_j = pairs(sequence[n][firstpos],sequence[n][secondpos],firstpos,secondpos) # seq_Phi.extend(pairs_j) return seq_Phi def single_probability_estimation ( binary , State_to_optimize , mean ): E_estimate = math . exp ( - ( numpy . dot ( binary , wStates [ 'w' + str ( State_to_optimize )]) - mean ) / ( k * t )) return E_estimate def multi_probability_estimation ( binary , mean ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_estimate_mult = math . exp ( - ( numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) - mean ) / ( k * t )) State_E_list . append ( E_estimate_mult ) return sum ( State_E_list ) def energy_mean_calc ( binary ): State_E_list = [] for a in range ( len ( modelsfilelist )): if modelsfilelist [ a ] != '98' and modelsfilelist [ a ] != '45' : E_mult = numpy . dot ( binary , wStates [ 'wState' + str ( modelsfilelist [ a ])]) State_E_list . append ( E_mult ) return numpy . mean ( State_E_list ) if write_opt_file_name : opt_filename = write_opt_file_name open ( opt_filename , 'w' ) open ( opt_filename , 'a' ) . write ( 'Probability' + ',' + str ( 'Sequence' ) + ',' + str ( 'chosen_state' ) + ' \\n ' ) #state_opt = ['State12'] #Might need to take out WT mutations from overall_solution_space to avoid mutating to wt best_seq_perstate_permutnum = {} if pdf_output_plot : from matplotlib.backends.backend_pdf import PdfPages pp = PdfPages ( pdf_output_plot ) for state_num in states_to_optimize_for_by_state_number : chosen_state = 'State' + str ( state_num ) print ( chosen_state ) rand_seq_list = [] boltz_list = [] objective_func_sequence_dict = {} for muts in range ( L - mutation_threshold + 1 ): objective_func_sequence_dict [ 'Mutations_' + str ( muts )] = [] #Test Optimization overall = [] for nn in range ( num_mutation_pathway_passes ): trial = [] for n in range ( inner_loop_trials ): if len ( trial ) <= mut_thresh : if n == 0 : aminoacidchain = [ wildtype [ i ] for i in range ( len ( wildtype ))] random_seq = '' . join ( aminoacidchain ) rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( random_seq ) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , random_seq ]) trial . append ( boltz_dist ) if n > 0 : randAAlist = [] for i in range ( 1 ): randAAlist . append ( random . randint ( 0 , L - 1 )) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : aachaintobemutated = list ( aminoacidchain ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : aachaintobemutated = list ( rand_seq_list [ - 1 ]) for mutantpositions in randAAlist : aachaintobemutated [ mutantpositions ] = random . choice ( overall_solution_space [ mutantpositions ]) random_seq = '' . join ( aachaintobemutated ) listseq = list ( random_seq ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) <= mutation_threshold : rand_seq_list . append ( aminoacidchain ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) if len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) > mutation_threshold : rand_seq_list . append ( listseq ) Phi = binary_conversion ( rand_seq_list [ - 1 ]) if mean_shift : mean_energy = energy_mean_calc ( Phi ) else : mean_energy = 0 single_E = single_probability_estimation ( Phi , chosen_state , mean_energy ) multi_E = multi_probability_estimation ( Phi , mean_energy ) boltz_dist = single_E / multi_E boltz_list . append ( boltz_dist ) Mut_num = L - len ([ a for a , b in zip ( rand_seq_list [ - 1 ], reference_seq ) if a == b ]) if boltz_list [ - 1 ] > boltz_list [ - 2 ]: trial . append ( boltz_dist ) objective_func_sequence_dict [ 'Mutations_' + str ( Mut_num )] . append ([ boltz_dist , '' . join ( listseq )]) pass if boltz_list [ - 1 ] <= boltz_list [ - 2 ]: del rand_seq_list [ - 1 ] del boltz_list [ - 1 ] stdout . write ( ' \\r Mutation Pathway Number = %s ' % str ( nn + 1 )) #This prints the current training set index on same line as an update stdout . flush () overall . append ( trial ) best_seq_perstate_permutnum [ str ( chosen_state )] = [] for muts in range ( L - mutation_threshold + 1 ): try : best_seq_perstate_permutnum [ str ( chosen_state )] . append ( max ( objective_func_sequence_dict [ 'Mutations_' + str ( muts )])) except ValueError : pass print ( ' \\n ' ) if self . display_plot and plot_separate : import matplotlib.pyplot as plt listt = [] for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): listt . append ([ i , best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . scatter ( states , probs ) plt . title ( 'Single State Optimization for State ' + str ( state_num )) if pdf_output_plot : pp . savefig () #plt.show() plt . close () if write_opt_file_name : for i in range ( len ( best_seq_perstate_permutnum [ str ( chosen_state )])): open ( opt_filename , 'a' ) . write ( str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 0 ]) + ',' + str ( best_seq_perstate_permutnum [ str ( chosen_state )][ i ][ 1 ]) + ',' + str ( chosen_state ) + ',' + str ( 'num_Mutations = ' ) + str ( i ) + ' \\n ' ) if pdf_output_plot : pp . close () self . best_results = best_seq_perstate_permutnum if self . display_plot and plot_together : import matplotlib.pyplot as plt for stuff in best_seq_perstate_permutnum : listt = [] for i in range ( len ( best_seq_perstate_permutnum [ stuff ])): listt . append ([ i , best_seq_perstate_permutnum [ stuff ][ i ][ 0 ]]) states = [ x [ 0 ] for x in listt ] probs = [ math . log ( x [ 1 ]) for x in listt ] plt . title ( 'Log Shifted Probability Plot' + ' \\n ' + 'For Most Probable Sequence Per State Per Mutation Number' ) plt . xlabel ( 'Mutation Number' ) plt . ylabel ( 'Log of Probability' ) plt . scatter ( states , probs ) elapsedtime = time . time () - starttime print ( 'time = %0.2f ' % elapsedtime ) return best_seq_perstate_permutnum","title":"single_state_design()"}]}